{"pages":[],"posts":[{"title":"Become Backend Developer with Golang","text":"My objective is create this document for anyone who want to completely beginner to Backend and Golang. I hope that you guys will find useful knowledge and materials here. Thanks to Developer Roadmap, with the paths that I can take and the technologies that I want to adopt in order to become a backend developer. You can open category Backend to follow all articles and learn about it. Section I. Introduction Chapter 1: Git - Version Control Chapter 2: Basic Terminal Usage Chapter 3: Data Structures &amp; Algorithms Chapter 4: SOLID, KISS, YAGNI Chapter 5: Github Chapter 6: Licenses Chapter 7: Semantic Versioning Chapter 8: SSH Chapter 9: HTTP/HTTPS and APIs Chapter 10: Design Patterns Chapter 11: Character Encodings Section II. Backend and Go Chapter 12: Golang Chapter 13: Command Line Applications Chapter 14: Dependency Management Tool Chapter 15: Standards and Best Practices Chapter 16: Package Chapter 17: Testing Chapter 18: Relational Databases Chapter 19: Practical Chapter 20: NoSQL Database Chapter 21: Caching Chapter 22: RESTfull APIs Chapter 23: Authentication/Authorization Methodologies Chapter 24: Message Brokers Chapter 25: Search Engine Chapter 26: Docker Chapter 27: Web Servers Chapter 28: Web Socket Chapter 29: GraphQL and Graph Databases Chapter 30: Other knowledges","link":"/Backend/become-backend-developer-with-golang/"},{"title":"Introduction to Machine Learning - Part 2","text":"Chào mọi người, mình đã quay trở lại. Sau vài tuần bận rộn chuẩn bị cho kế hoạch tương lai cũng như chưa tạo được thói quen viết bài, mình đã trở lại và viết tiếp phần 2 cho chuỗi bài Introduction to Machine Learning. Introduction to Machine Learing - Part 1 History of Machine LearningỞ Part 1, mình đã giới thiệu và đưa mọi người tiếp cận khái niệm Machine Learning là gì. Tiếp theo mình sẽ đề cập một chút về lịch sử của nó. Đầu tiên giới thiệu cho bạn một bức ảnh (nguồn từ NVIDIA) Trong bức ảnh, thì mình sẽ có 3 keyword cần nói, đó là Artificial Intelligence, Machine Learning và Deep Learning. Có thể nói thì khi ngành khoa học máy tính xuất hiện, mục tiêu là làm ra những cỗ máy như con người. Và từ đó, năm 1956 cũng xuất hiện khái niệm Artificial Intelligence - Trí tuệ nhân tạo. Sang năm 1959, một lĩnh vực con của AI là Machine Learning ra đời, được định nghĩa bởi Arthur Samuel. Machine Learning là một lĩnh vực của khoa học máy tính. Machine Learning như là một phương pháp thành công để đạt được trí thông minh nhân tạo (AI). Những năm gần đây, sự phát triển của các hệ thống cũng lượng dữ liệu lớn, một lĩnh vực mới được ra đời, gọi là Deep Learning. Deep Learning đã giúp máy thực thi những việc tưởng chừng như không thể nào cách đây một thập kỉ, nó là tập con của Machine Learning. Và Deep Learning chính là một trong những kĩ thuật để triển khai Machine Leaning. Process of Machine LearningPhía trên mình đã chia sẻ về Lịch sử, cũng như mối liên hệ giữa Artificial Intelligence, Machine Learning và Deep Learning. Tiếp theo, mình sẽ chia sẻ cho mọi người về process của một bài toán Machine Learning là như thế nào. Đầu tiên, thứ phải nói là quan trọng nhất trong một bài toán Machine Learning đó chính là data - dữ liệu. Nếu một bài toán không có dữ liệu thì bạn không nên áp dụng Machine Leaning vào bài toán đó. Sau khi có dữ liệu, tuỳ thuộc vào bài toán của bạn, bạn sẽ chọn thuật toán phù hợp để phân tích dữ liệu của bạn. Xử lý dữ liệu bằng thuật toán Machine Learning, chúng ta sẽ được kết quả là model. Nếu các bạn tiếp xúc với Machine Learning, chắc chắn các bạn sẽ biết tới model. Thực ra cũng không có gì cao siêu cả, model nó cũng giống như một function. Việc của chúng ta là đưa đầu vào vào function đó, nó sẽ đưa cho mình đầu ra. Cuối cùng, mình tổng hợp lại quá trình của bài toán Machine Learning qua hình ảnh này Tới đây là kết thúc phần 2 rồi, Phần 3 tiếp theo mình sẽ giới thiệu Categories of Machine Learning - các loại học. Tại sao lại có các loại học? Dựa vào đâu để phân biệt? Và các ví dụ. Các bạn đón đọc nhé Cảm ơn mọi người 😘😘😘","link":"/Machine-Learning/introduction-to-machine-learning-part-2/"},{"title":"Introduction to Machine Learning - Part 1","text":"Chào mọi người, đây là bài blog đầu tiên trong sự nghiệp viết lách của mình, hy vọng sẽ mang lại kiến thức cho mọi người. Giới thiệu về mình một chút, mình tên là Sự, mình bắt đầu với iOS, sau này thì có vọc thêm nhiều thứ. Mọi người muốn xem chi tiết về mình thì của sang trang CV nhé. Ý định viết blog cũng xuất hiện trong đầu rất là lâu rồi, bây giờ mới ngồi viết một cách nghiêm túc. Thôi tránh lan man, mình đi vào chủ đề chính nhé 😉 Vì nội dung mình muốn chia sẻ hơi nhiều, nên mình đã tách ra nhiều Part, các bạn nhớ theo dõi nhé, cảm ơn các bạn. Why this topic?Mình tìm hiểu Machine Learning trong vòng 5 tháng trở lại đây, và để có cái gọi là output trong 5 tháng, thì mình và một anh cùng team research đã trình bày topic Introduction to Machine Learning trước công ty, người tham gia buổi chia sẻ của tụi mình gần 80 người. Sau khi trình bày xong, giờ mình chọn nó cho bài blog đầu tiên của mình. Và tất nhiên là sườn của bài blog sẽ giống trong slide 😈😈😈 Đây là poster mà phía công ty đã tạo ra cho tụi mình, và mình đứa ở phía trên: Some interesting applicationsTrước khi giới thiệu về Machine Learning, mình sẽ show cho mọi người một vài ứng dụng Đầu tiên, ứng dụng Face Recognition in ARKit, đây là ứng dụng iOS nhận diện khuôn mặt một người, và cho biết người đó là ai. Tiếp theo, ứng dụng Chatbot - Speech Regnition, một ứng dụng Web, nhận diện giọng nói sau đó xử lý để một chatbot reply. Cuối cùng là ứng dụng nhận diện chữ viết tay (cụ thể là con số), như mọi người đã viết, mỗi người sẽ có cách viết khác nhau, và ứng dụng này vẫn nhận diện được chữ số mà mình viết Phía trên là 3 ứng dụng mà mình muốn chia sẻ cho mọi người thấy, tất nhiên tất cả đều áp dụng Machine Learning. Vậy câu hỏi đặt ra là tại sao Machine Learning nó lại được nhắc đến nhiều như vậy tại thời điểm hiện tại, cũng như việc áp dụng Machine Learning vào các ứng dụng cũng không phải là ít 🤔🤔🤔 ??!!?? Why is Machine Learning trending now?Ở đây mình có 3 ý muốn chia sẻ tới mọi người. Thứ nhất, việc phần cứng - hardware tại thời điểm hiện tại đã đủ đáp ứng cho Machine Learning. Theo một vài thông tin mà mình đã đọc, thì phần cứng đã hỗ trợ cho những ứng dụng Machine Learning làm các công việc chỉ tốn thời gian 1 ~ 2 tuần, trong khi nếu không có Machine Learning thì có thể mất tới 10 tháng. Thứ hai, dữ liệu - data ngày nay có một số lượng rất là lớn, và tất nhiên nó chứa đựng một khối lượng tri thức cực kỳ lớn mà con người muốn khám phá, và công cụ để khám phá nó là gì? Chính là Machine Learning. Cuối cùng, Machine Learning đã mang lại những ứng dụng thực tế hết sức hữu ích cũng như giải quyết ở nhiều lĩnh vực như: Sinh học, Tài chính, Xử lý ngôn ngữ tự nhiên, Hệ thống recommendation, Thị giác máy tính, xủ lý hình ảnh,… What is Machine Learning?Nãy giờ đã nói quá nhiều về những lợi ích mà Machine Learning mang lại cũng như các ứng dụng của nó, giờ mình bắt đầu với câu hỏi kinh điển Machine Learning là gì? Programming vs Machine LearningTrước khi nói về định nghĩa của nó, mình quay trở lại một chút với Programming Như ở hình trên, mọi người có thể thấy được, đối với lập trình bình thường, khi bắt đầu định nghĩa một công việc nào đó, thì mình sẽ sử dụng những luật lệ hay yêu cầu cụ thể để định nghĩa, rồi sau đó, mình đưa input (data) vào, công việc đó sẽ đánh giá input dựa trên những yêu cầu (rules) và sẽ đưa ra output (answer). Nhưng khác với Programming, đối với Machine Learning thì sẽ có mô hình như sau: Bài toán của Machine Learning lại khác, chúng ta sẽ không cần quan tâm rules sẽ là gì, khi bắt đầu định nghĩa một công việc của bài toán Machine Learning thì chúng ta chỉ cần cung cấp một lượng lớn các answers và data, để từ đó, Machine Learning sẽ học từ các answers để suy ra rules. Lúc này mình đưa vào input và công việc sẽ dự đoán output. Để mọi người dễ hiểu hơn về Programming và Machine Learning, mình sẽ đưa ra một ví dụ cụ thể, bài toán của mình là: Đầu vào là một String, đầu ra là câu trả lời String đó có phải là email hay không (bài toán verify email). Đối với Programming, để xử lý công việc này, mình sẽ define một function có chứa rules là: email phải có các kí tự chữ, số, gạch ngang, dấu chấm…, tiếp theo là kí tự @, cuối cùng là một domain. Lúc này, việc tiếp theo, chỉ cần truyền input là một String, nếu đúng như rules thì suy ra String đó là email. Đối với Machine Learning, cái đầu tiên mình cần đó là answers. Ví dụ mình sẽ có answers: contact@mlsuho.me là email. hovansu.it@gmail.com là email. hovansu8@gmail.com là email. contact@ không phải là email. @mlsuho.me không phải là email.… Lúc này mình sẽ cung cấp answers, việc của Machine Learning là lúc mình đưa vào một chuỗi String mới, nó phải dự đoán xem String đó có phải là email hay không. Công việc của developer như mình không cần phải định nghĩa rules nữa, đó là của Machine Learning. Human vs Machine LearningMình đã hiểu hơn một chút về Machine Learning thông qua Programming. Để mọi người nắm thêm về Machine Learning, mình xin chia sẻ thêm một cách giải thích về nó mà mình lượm lặt được. Đầu tiên, cái gì xuất hiện cũng có mục đích của nó. Machine Learning xuất hiện cho bước đầu mong muốn làm ra những cỗ máy có thể thay thế con người. Con người chúng ta, khi chúng ta thực hiện một điều gì đó, cũng đều dựa trên kinh nghiệm (experience) mà ta có được, và để có kinh nghiệm thì chúng ta phải học. Ví dụ lúc còn nhỏ, để học chữ A, ta phải được bố mẹ dạy, chúng ta sẽ tiếp xúc với nhiều chữ A (học được nhiều chữ A hơn), lúc này kinh nghiệm về chữ A của mình nhiều hơn, nên bây giờ nhìn bất kì chữ A mới nào, chúng ta cũng biết. Còn máy móc lúc này thì sao? Máy móc thì đã được con người lập trình, cho nó biết nó phải làm gì step by step, con người đưa cho máy móc instructions. Đối với Machine Learning, lúc này con người đã mong muốn máy móc như con người, không còn muốn làm theo những bước đã định nghĩa sẵn. Việc học từ kinh nghiệm của con người đã được áp dụng vào máy móc. Nhưng không giống con người là trải nghiệm dựa trên kinh nghiệm, máy móc sẽ học từ chính data mà con người cung cấp, hay answer ở phía trên mình có đề cập. DefinitionNãy giờ mình đã đề cập tới Programming, Human và Machine Learning bằng những cách hiểu của mình. Giờ mình đưa ra khái niệm của Machine Learning của Arthur Samuel - một nhà khoa học máy tính, người đã cho ra đời khái niệm Machine Learning “The field of study that gives computers the ability to learn without being explicitly programmed” - Arthur Samuel Tạm dịch là: Machine Learning là một lĩnh vực trong khoa học máy tính, có khả năng tự học dựa trên dữ liệu được đưa vào mà không cần phải lập trình cụ thể. Vậy là mình giới thiệu xong cho mọi người về Machine Learning là gì. Chắc Part 1 sẽ dừng lại ở đây, mình thấy hơi dài rồi. Hẹn gặp lại mọi người ở Part 2 với những nội dung hấp dẫn hơn 😘😘😘 Một vài hình ảnh lấy từ các trang web:Face Recognition in ARKitChatbot - Speech RegnitionBuild a Handwritten","link":"/Machine-Learning/introduction-to-machine-learning-part-1/"},{"title":"Introduction to Machine Learning - Part 3","text":"Sau khoảng thời gian ôn luyện tiếng anh để thi IELTS, giờ mình quay lại để viết những gì còn dang dở 🤣🤣🤣. Cũng hơn 2 tháng mới viết lại một bài, hiệu suất quá kém, mình sẽ cố gắng để viết nhiều hơn về technical hay những chia sẻ khác. Introduction to Machine Learing - Part 1Introduction to Machine Learing - Part 2 Ở phần 3 này mình sẽ giới thiệu các loại học có trong Machine Learning. Trong Machine Learning, có rất nhiều cách để giải quyết một bài toán, và dựa vào những dữ liệu đầu vào cũng nhưng yêu cầu của bài toán, người ta đã định nghĩa ra những loại học trong Machine Learning. Hôm nay mình sẽ giới thiệu 2 loại chính là: Supervised Learning và Unsupervised Learning (ngoài ra còn có các loại khác, bài mình sẽ không đề cập nhé, vì kiến thức của mình cũng còn hạn chế). Và để việc chia ra các loại này, người ta đều dựa vào data - dữ liệu để có thể phân loại bài toán cần thiết. Mình sẽ bắt đầu với Supervised Learning nhé. Supervised LearningMình tạm dịch Supervised Learning(SL) sang tiếng việt là Học có giám sát. Như mình đã đề cập ở Part 2, bài toán Machine Learning là bài toán mình đưa dữ liệu vào rồi áp dụng các thuật toán để có model. Vậy tại sao lại dùng từ giám sát, với một bài toán áp dụng các học SL thì dữ liệu chúng ta cung cấp là chúng ta đã biết dữ liệu đầu vào và đầu ra. Do đó chúng ta có thể “giám sát” dữ liệu. Để biết rõ hơn về Supervised Learning, về dữ liệu biết đầu vào và đầu ra, mình sẽ đề cập về 2 kĩ thuật chính của cách học này đó là: Classification và Regression. ClassificationĐầu tiên mình sẽ nói tới Classification (phân loại) trong Supervised Learning. Đây là một trong những kĩ thuật tìm hiểu và nghiên cứu nhiều nhất trong Machine Learning. Sau khi áp dụng kĩ thuật này, model sẽ có khả năng dự đoán các giá trị theo kiểu phân loại. Mình sẽ có những ví dụ để mọi người dễ hiểu, những ứng dụng như phân loại chó mèo khi mình cung cấp một hình ảnh về chó hoặc mèo, hay ứng dụng phân biệt loài hoa hồng hay hoa lan, ngoài ra các ứng dụng nhận diện mặt hay đối tượng… các ứng dụng đó đều là các ví dụ sử dụng Classification. Để rõ hơn, mình sẽ phân tích một bài toán cụ thể nhé Dự đoán giới tính dựa trên chiều cao và cân nặng Và dữ liệu của bài toán Giờ bắt đầu phân tích một chút nhé, với bài toán này, theo yêu cầu, thì đầu vào của chúng ta sẽ là chiều cao và cân nặng còn đầu ra sẽ là giới tính. Tiếp theo khi nhìn vào tập dữ liệu để train, thì chúng ta đã có đầy đủ input và output. Vậy ở đây loại học mình sẽ áp dụng là Supervised Learning. Sau đó nhìn vào output mình sẽ thấy giới tính ở đây chỉ có Nam hoặc Nữ, đây là phân loại giới tính, nên kĩ thuật mình dùng sẽ là Classification. Sau khi có bài toán và dữ liệu thì chúng ta có thể phân tích được kĩ thuật mà mình sử dụng sẽ là gì. Khi nhắc tới Machine Learning thì mình không thể nhắc tới thuật toán của mỗi kĩ thuật. Với Classification, mình xin giới thiệu tới mọi người một vài thuật toán, nếu mọi người thích thì có thể tìm hiểu để áp dụng vào bài toán của mình Các thuật toán: Support vector machine (SVM) Decision tree K-nearest neighbor Naïve Bayes Neural networks RegressionMột kĩ thuật thứ hai trong Supervised Learning là Regression (Hồi Quy). Khác với Classification kĩ thuật này áp dụng cho những bài toán có model dự đoán những giá trị thực (những con số). Mình sẽ đề cập chi tiết ở ví dụ để mọi người hiểu rõ hơn. Những ứng dụng có sử dụng kĩ thuật này: Dự đoán tuổi dựa trên hình ảnh, hay ứng dụng dự đoán nhiệt độ của ngày mai. Để mọi người hiểu rõ hơn thì mình sẽ có ví dụ như thế này Dự đoán cân nặng dựa trên chiều cao Ta sẽ phân tích bài toán và dữ liệu train để chọn kĩ thuật nhé. Đầu tiên, bài toán này với input là chiều cao và output là cân nặng. Dựa vào dữ liệu train, ta đều thấy input và output của dữ liệu, nên chúng ta sẽ áp dụng cách học Supervised Learning. Tiếp theo để ý output của dữ liệu, không giống ở ví dụ của phần Classifiation, output là giới tính Nam hoặc Nữ, ở ví dụ này, output là một con số, và mình không biết trước cụ thể về output. Khi gặp bài toán và dữ liệu này, mình sẽ áp dụng kĩ thuật Regression Và các thuật toán trong Regression là: Linear / Nonlinear model Regularization Stepwise regression Bagged decision trees Neural networks Unsupervised LearningTiếp theo chúng ta sẽ qua loại học thứ hai là Học không giám sát - Unsupervised Learning. Về phần này thì mình chưa làm + chưa có kinh nghiệm nên chỉ có thể chia sẻ kiến thức lý thuyết mà mình hiểu được về nó, rồi chia sẻ cho mọi người cùng biết. Đầu tiên, Unsupervised Learning ngược lại với Supervised Learning, nó không hướng tới việc tìm một correct output. Vậy model khi sử dụng Unsupervised Learning thì đưa ra output gì? Model này hướng tới việc tìm ra các structure, relationshiprelationship ẩn sâu trong dữ liệu mà ta không thấy được. Và một điều đặt biết của tập dữ liệu train sẽ không có đầu ra, mình chỉ cung cấp dữ liệu có đầu vào. Và kĩ thuật thường được sử dụng trong Unsupervised Learning là Clustering (Phân cụm). Ví dụ một chút nhé, mình đang bán một mặt hàng, như cây bút và khách hàng của mình là khác nhau, từ học sinh, sinh viên hay doanh nhân. Sau khi mua hàng của mình, mình sẽ có dữ liệu của khách hàng. Sau đó mình áp dụng Unsupervised Learning vào dữ liệu của mình, có thể mình sẽ tìm ra điểm chung của khách hàng của mình, rồi từ điểm chung đó, mình sẽ quảng cáo tới những người khác dựa vào điểm chung đó, vừa nâng cao lợi nhuận vừa tiết kiếm chi phí quảng cáo. ClusteringTiếp theo mình sẽ nói về kĩ thuật Clustering (Phân cụm) trong Unsupervised Learning. Kĩ thuật này dùng để phân nhóm toàn bộ dữ liệu thành các nhóm nhỏ khác nhau dựa vào sự liên quan về tính chất các dữ liệu về các nhóm Mình sẽ có hình ảnh ví dụ về ứng dụng nhận dạng số Nguồn datascienceplus Ở đây, đầu vào dữ liệu là mình cung cấp các số mà mình không cho biết đó là số nào, thông qua kĩ thuật Cluster, nó sẽ tự phân loại gần như chính xác các số đó dựa trên các nét vẽ của các chữ số đó. (có thể sẽ có một sai số như hình phía trên) Mình sẽ chia sẻ thêm một vài thuật toán của kĩ thuật Clustering: K-means and k-medoids Hierarchical clustering Gaussian mixture models Hidden Markov models Fuzzy c-means clustering Tới đây là mình đã kết thúc phần 3 cũng như chuỗi bài về Introduction to Machine Learning. Cảm ơn mọi người đã theo dõi. Có gì thắc mắc hoặc bài viết mình sai xót, mọi người cứ bình luận.","link":"/Machine-Learning/introduction-to-machine-learning-part-3/"},{"title":"Chapter 1 - Git - Version Control","text":"Everything you need to know about git. Thanks to Scott Chacon and Ben Straub, authors of the book Pro Git In this chapter, I will show basic knowledges from Pro Git book, if you want more detail, you should download the book and read it. Getting StartedThis section will be about getting started with Git, then move on how to get Git running on system and set up to start working with. Version ControlVersion control is a system that records changes to a file or set of files over time so that you can recall specific versions later. If you are a developer and you want to keep every version of your code, a Version Control System (VCS) is a very wise thing to use. It allows you to revert selected files back to a previous state, revert the entire project back to a previouse state, compare changes over time, see who last modified something that might be causing a problem (then you can burn them 🤣🤣🤣), and more. Git is a Distributed Version Control System (DVCS), in a DVCS, clients don’t just check out the latest snapshot of the files; rather, the fully mirror the repository, including its full history. Thus, if any server dies, and these systems were collaborating via the server, any of the client repositories can be copied back up to the server to restore it. What is Git?So, what is Git in a nutshell? Snapshots, Not DifferencesWith Git, every time you commit, or save the state of your project, Git basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot. To be efficient, if files have not changed, Git doesn’t store the file again, just a link to the previous identical file it has already stored. Nearly Every Operation Is LocalMost operations in Git need only local fils and resources to operate - generally no information is needed from another computer on your network. You have the entire history of the project right there on your local disk, most operations seem almost instantaneous. For example, to browse the history of the proejct, Git doesn’t need to go out to the sever to get the history and display it for you - it simply reads it directly from your local database. Git Has IntegrityEverything in Git is checksummed before it is stored and is then referred to by that checksums. This means it’s impossible to change to contents of any file or directory without Git knowing about it. Git Generally Only Adds DataWhen you do actions in Git, nearly all of them only add data to the Git database. It is hard to get the system to do anything that is not undoable or to make it erase data in any way. After you commit a a snapshot into Git, it is very difficult to lose, especially if you regularly push your database to another repository. This makes using Git a joy because we know we can experiment without the danger of severely screwing things up. The Three StatesPay attention now - here is the main thing to remember about Git if you want the rest of your learning process to go smoothly. Git has three main states that your files can reside in: committed, modified, and staged: Committed means that the data is safely stored in your local database Modifed means that you have changed the file but have not committed it to your database yet. Staged means that you have marked a modified file in its current version to go into your next commit snapshot The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer The working tree (working directory) is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify. The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit. The basic Git workflow goes something like this: You modify files in your working tree You selectively stage just those changes you want to be part of your next commit, which adds only those changes to the staging area. You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory. The Command LineThere are a lot of different ways to use Git. There are the original command-line tools, and there are many graphical user interfaces of varying capabilities. For backend developer, I suggest using Git on the command line. For one, the command line is the only place you can run all Git commands. Installing GitYou need to go to the website git-scm.com for download and install Git. After download and install, run git from terminal the very first time 1git --version First-Time Git SetupNow that you have Git on your system, you will want to do a few things to customize your Git environment. First, you can view all of your settings and where they are coming from using: 1git config --list --show-origin Your IdentityThe first thing you should do when you install Git is set your username and email address. This is important because every Git commit uses this information, and it’s immutably baked into the commits you start creating 12$ git config --global user.name suho$ git config --global user.email suho@example.com Because Git will always use that information for anything you do on that system so you need to to do this only once if you pass the --global option. Without --global, you will use different name or email for specific projects. Checking Your SettingsIf you want to check your configuration, run: 1git config --list Git BasicsIn this section, we will learn how to use Git in the 80% of cases you’ll encounter most often. After this section, you will be able to clone a repository, see what has happened in the history of the project, modify files, and contribute changes. Getting a Git RepositoryYou typically obtain a Git repository in one of two ways: You can take a local directory that is currently not under version control, and turn it into a Git repository, or You can clone an existing Git repository from elsewhere. Initializing a Repository in an Existing DirectoryYou first need to go to that project’s directory. 1$ cd ~/your-project and type: 1$ git init This creates a new subdirectory named .git that contains all of your necessary repository files — a Git repository skeleton Cloning an Existing RepositoryIf you want to get a copy of an existing Git repository — for example, a project you’d like to contribute to — the command you need is git clone. Every version of every file for the history of the project is pulled down by default when you run git clone. Recording Changes to the RepositoryEach file in your working directory can be in one of two states: tracked or untracked. Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged. In short, tracked files are files that Git knows about. Untracked files are everything else — any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven’t edited anything. Checking the Status of Your FilesThe main tool you use to determine which files are in which state is the git status command. 1$ git status Tracking New FilesIn order to begin tracking a new file, you use the command git add. To begin tracking the README file, you can run this: 1$ git add [fileName] Staging Modified Filesgit add is a multipurpose command — you use it to begin tracking new files, to stage files, and to do other things like marking merge-conflicted files as resolved. Short StatusWhile the git status output is pretty comprehensive, it’s also quite wordy. Git also has a short status flag so you can see your changes in a more compact way 1$ git status -s Ignoring FilesOften, you’ll have a class of files that you don’t want Git to automatically add or even show you as being untracked. These are generally automatically generated files such as log files or files produced by your build system. In such cases, you can create a file listing patterns to match them named .gitignore. Here is an example .gitignore file: 123456789101112# ignore all .a files*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in any directory named buildbuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directory and any of its subdirectoriesdoc/**/*.pdf The rules for the patterns you can put in the .gitignore file are as follows: Blank lines or lines starting with # are ignored. Standard glob patterns work, and will be applied recursively throughout the entire working tree. You can start patterns with a forward slash (/) to avoid recursivity. You can end patterns with a forward slash (/) to specify a directory. You can negate a pattern by starting it with an exclamation point (!). Viewing Your Staged and Unstaged ChangesIf you want to know exactly what you changed, not just which files were changed — you can use the git diff command 1$ git diff Committing Your ChangesNow that your staging area is set up the way you want it, you can commit your changes. Remember that anything that is still unstaged — any files you have created or modified that you haven’t run git add on since you edited them — won’t go into this commit. They will stay as modified files on your disk. In this case, let’s say that the last time you ran git status, you saw that everything was staged, so you’re ready to commit your changes. The simplest way to commit is to type git commit: 1$ git commit Alternatively, you can type your commit message inline with the commit command by specifying itafter a -m flag, like this: 1$ git commit -m \"Story 01: Fix Login UI` Viewing the Commit HistoryAfter you have created several commits, or if you have cloned a repository with an existing commit history, you’ll probably want to look back to see what has happened. The most basic and powerful tool to do this is the git log command. 1$ git log Common Options to git log Option Description -p Show the patch introduced with each commit. –stat Show statistics for files modified in each commit. –shortstat Display only the changed/insertions/deletions line from the –stat command. –name-only Show the list of files modified after the commit information. –name-status Show the list of files affected with added/modified/deleted information as well. –abbrev-commit Show only the first few characters of the SHA-1 checksum instead of all 40. –relative-date Display the date in a relative format (for example, “2 weeks ago”) instead of using the full date format. –graph Display an ASCII graph of the branch and merge history beside the log output. –pretty Show commits in an alternate format. Options include oneline, short, full, fuller, and format (where you specify your own format). –oneline Shorthand for –pretty=oneline –abbrev-commit used together Undoing ThingsOne of the common undos takes place when you commit too early and possibly forget to add some files, or you mess up your commit message. If you want to redo that commit, make the additional changes you forgot, stage them, and commit again using the –amend option: 1$ git commit --amend Unstaging a Staged FileUse git reset HEAD &lt;file&gt;... to unstage. It’s true that git reset can be a dangerous command, especially if you provide the --hard flag. However, in the scenario described above, the file in your working directory is not touched, so it’s relatively safe. Unmodifying a Modified FileWhat if you realize that you don’t want to keep your changes to the CONTRIBUTING.md file? How can you easily unmodify it — revert it back to what it looked like when you last committed. Use git checkout -- &lt;file&gt;... to discard changes in working directory. Working with RemotesTo be able to collaborate on any Git project, you need to know how to manage your remote repositories. Remote repositories are versions of your project that are hosted on the Internet or network somewhere. Remote repositories can be on your local machine. Showing your remotesTo see which remote servers you have configured, you can run the git remote command. 1$ git remote You can also specify -v, which shows you the URLs that Git has stored for the shortname to be used when reading and writing to that remote. 1$ git remote -v Adding Remote RepositoriesHere’s how to add a new remote explicitly. To add a new remote Git repository as a shortname you can reference easily, run git remote add &lt;shortname&gt; &lt;url&gt;: 1$ git remote add suho https://github.com/suho/backend-and-go Now you can fetch all the information 1$ git fetch suho Fetching and Pulling from Your RemotesAs you just saw, to get data from your remote projects, you can run: 1$ git fetch &lt;remote&gt; If your current branch is set up to track a remote branch, you can use the git pull command to automatically fetch and then merge that remote branch into your current branch. Pushing to Your RemotesWhen you have your project at a point that you want to share, you have to push it upstream. The command for this is simple: git push &lt;remote&gt; &lt;branch&gt;. If you want to push your master branch to your origin server (again, cloning generally sets up both of those names for you automatically), then you can run this to push any commits you’ve done back up to the server: 1$ git push origin master Inspecting a RemoteIf you want to see more information about a particular remote, you can use the git remote show &lt;remote&gt; command. 1$ git remote show origin Renaming and Removing RemotesYou can run git remote rename to change a remote’s shortname. For instance, if you want to renamesuho to sh, you can do so with git remote rename: 1$ git remove remove suho sh TaggingGit has the ability to tag specific points in a repository’s history as being important. Typically, people use this functionality to mark release points (v1.0, v2.0 and so on). In this section, you’ll learn how to list existing tags, how to create and delete tags, and what the different types of tags are. Listing Your TagsListing the existing tags in Git is straightforward. Just type git tag (with optional -l or –list): 1$ git tag Creating TagsGit supports two types of tags: lightweight and annotated. A lightweight tag is very much like a branch that doesn’t change — it’s just a pointer to a specific commit. Annotated tags, however, are stored as full objects in the Git database. They’re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It’s generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason don’t want to keep the other information, lightweight tags are available too. Annotated Tags Creating an annotated tag in Git is simple. The easiest way is to specify -a when you run the tag command: 1$ git tag -a v0.0.1 -m \"Version 0.0.1\" You can see the tag data with git show command 1$ git show v0.0.1 Lightweight Tags Another way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file — no other information is kept. To create a lightweight tag, don’t supply any of the -a, -s, or -m options, just provide a tag name: 1$ git tag v0.0.2-lw If you run git show on the tag (v0.0.2-lw), you don’t see the extra tag information. Sharing TagsBy default, the git push command doesn’t transfer tags to remote servers. You will have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches — you can run git push origin &lt;tagname&gt; 1234$ git push origin v0.0.1# Push all tagsgit push origin --tags Deleting TagsTo delete a tag on your local repository, you can use git tag -d &lt;tagname&gt;. For example, we could remove our lightweight tag above as follows: 1$ git tag -d v0.0.2-lw Note that this does not remove the tag from any remote servers. The way to delete a remote tag is with: 1$ git push origin --delete &lt;tagname&gt; Checking out TagsIf you want to view the versions of files a tag is pointing to, you can do a git checkout of that tag 1$ git checkout v0.0.1 Git BranchingBranching means you diverge from the main line of development and continue to do work without messing with that main line. Git’s branching model as its killer feature. The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast. Branches in a NutshellThe default branch name in Git is master. As you start making commits, you’re given a master branch that points to the last commit you made. Every time you commit, the master branch pointer moves forward automatically. The “master” branch in Git is not a special branch. It is exactly like any other branch. The only reason nearly every repository has one is that the git init command creates it by default and most people don’t bother to change it. Creating a New BranchWhat happens when you create a new branch? Well, doing so creates a new pointer for you to move around. Let’s say you want to create a new branch called testing. You do this with the git branch command: 1$ git branch testing This creates a new pointer to the same commit you’re currently on. The git branch command only created a new branch — it didn’t switch to that branch. Switching BranchesTo switch to an existing branch, you run the git checkout command. Let’s switch to the new testing branch: 1$ git checkout testing This moves HEAD to point to the testing branch. The HEAD branch moves forward when a commit is made This is interesting, because now your testing branch has moved forward, but your master branch still points to the commit you were on when you ran git checkout to switch branches. Let’s switch back to the master branch: 1$ git checkout master Now, let’s make a few changes and commit again. Basic Branching and MergingLet’s go through a simple example of branching and merging with a workflow that you might use inthe real world. You’ll follow these steps: Do some work on a website. Create a branch for a new user story you’re working on. Do some work in that branch. At this stage, you’ll receive a call that another issue is critical and you need a hotfix. You’ll do thefollowing: Switch to your production branch. Create a branch to add the hotfix. After it’s tested, merge the hotfix branch, and push to production. Switch back to your original user story and continue working. Basic BranchingFirst, let’s say you’re working on your project and have a couple of commits already on the master branch. You’ve decided that you’re going to work on issue #53 in whatever issue-tracking system your company uses. To create a new branch and switch to it at the same time, you can run the git checkout command with the -b switch: 1$ git checkout -b iss53 This is shorthand for: 12$ git branch iss53git checkout iss53 You work on your website and do some commits. Doing so moves the iss53 branch forward, because you have it checked out (that is, your HEAD is pointing to it). Now you get the call that there is an issue with the website, and you need to fix it immediately. With Git, you don’t have to deploy your fix along with the iss53 changes you’ve made, and you don’t have to put a lot of effort into reverting those changes before you can work on applying your fix to what is in production. All you have to do is switch back to your master branch. 1$ git checkout master Next, you have a hotfix to make. Let’s create a hotfix branch on which to work until it’s completed 1$ git checkout -b hotfix You can run your tests, make sure the hotfix is what you want, and finally merge the hotfix branch back into your master branch to deploy to production. You do this with the git merge command 12$ git checkout mastergit merge hotfix After your super-important fix is deployed, you’re ready to switch back to the work you were doing before you were interrupted. However, first you’ll delete the hotfix branch, because you no longer need it — the master branch points at the same place. You can delete it with the -d option to git branch: 1$ git branch -d hotfix Now you can switch back to your work-in-progress branch on issue #53 and continue working on it. 1$ git checkout iss53 It’s worth noting here that the work you did in your hotfix branch is not contained in the files in your iss53 branch. If you need to pull it in, you can merge your master branch into your iss53 branch by running git merge master, or you can wait to integrate those changes until you decide to pull the iss53 branch back into master later. Basic MergingSuppose you’ve decided that your issue #53 work is complete and ready to be merged into your master branch. In order to do that, you’ll merge your iss53 branch into master, much like you merged your hotfix branch earlier. All you have to do is check out the branch you wish to merge into and then run the git merge command: 12$ git checkout mastergit merge iss53 Now that your work is merged in, you have no further need for the iss53 branch. You can close the ticket in your ticket-tracking system, and delete the branch: 1$ git branch -d iss53 Basic Merge ConflictsOccasionally, this process doesn’t go smoothly. If you changed the same part of the same file differently in the two branches you’re merging, Git won’t be able to merge them cleanly. If your fix for issue #53 modified the same part of a file as the hotfix branch, you’ll get a merge conflict that looks something like this 1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. Anything that has merge conflicts and hasn’t been resolved is listed as unmerged. Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts. Your file contains a section that looks something like this: 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=\"footer\"&gt;Contact : e.support@example.com&lt;/div&gt;=======&lt;div id=\"footer\"&gt;Please contact us at support@example.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html This means the version in HEAD (your master branch, because that was what you had checked out when you ran your merge command) is the top part of that block (everything above the =======), while the version in your iss53 branch looks like everything in the bottom part. In order to resolve the conflict, you have to either choose one side or the other or merge the contents yourself. For instance, you might resolve this conflict by replacing the entire block with this: 123&lt;div id=\"footer\"&gt;please contact us at email.support@github.com&lt;/div&gt; Branch ManagementNow that you’ve created, merged, and deleted some branches, let’s look at some branchmanagement tools that will come in handy when you begin using branches all the time. The git branch command does more than just create and delete branches. If you run it with no arguments, you get a simple listing of your current branches: 1234$ git branch iss53* master testing Notice the * character that prefixes the master branch: it indicates the branch that you currentlyhave checked out (i.e., the branch that HEAD points to) To see the last commit on each branch, you can run git branch -v: 1$ git branch -v The useful --merged and --no-merged options can filter this list to branches that you have or have not yet merged into the branch you’re currently on 12$ git branch --merged$ git branch --no-merged RebasingIn Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase. In this section you’ll learn what rebasing is, how to do it, why it’s a pretty amazing tool, and in what cases you won’t want to use it. The Basic RebaseIf you go back to an earlier example from Basic Merging, you can see that you diverged your workand made commits on two different branches. The easiest way to integrate the branches, as we’ve already covered, is the merge command. However, there is another way: you can take the patch of the change that was introduced in C4 and reapply it on top of C3. In Git, this is called rebasing. With the rebase command, you can take all the changes that were committed on one branch and replay them on a different branch. For this example, you would check out the experiment branch, and then rebase it onto the master branch as follows 12$ git checkout experiment$ git rebase master At this point, you can go back to the master branch and do a fast-forward merge. 12$ git checkout master$ git merge experiment More Interesting RebasesYou can also have your rebase replay on something other than the rebase target branch. For example, you branched a topic branch (server) to add some server-side functionality to your project, and made a commit. Then, you branched off that to make the client-side changes (client) and committed a few times. Finally, you went back to your server branch and did a few more commits. Suppose you decide that you want to merge your client-side changes into your mainline for a release, but you want to hold off on the server-side changes until it’s tested further. You can take the changes on client that aren’t on server (C8 and C9) and replay them on your master branch by using the --onto option of git rebase: 1$ git rebase --onto master server client This basically says, “Take the client branch, figure out the patches since it diverged from the server branch, and replay these patches in the client branch as if it was based directly off the master branch instead.” It’s a bit complex, but the result is pretty cool. Now you can fast-forward your master branch 12$ git checkout master$ git merge client Let’s say you decide to pull in your server branch as well. You can rebase the server branch onto the master branch without having to check it out first by running git rebase &lt;basebranch&gt; &lt;topicbranch&gt; — which checks out the topic branch (in this case, server) for you and replays it onto the base branch (master): 1$ git rebase master server Then, you can fast-forward the base branch (master): 12$ git checkout master$ git merge server You can remove the client and server branches because all the work is integrated and you don’t need them anymore 12$ git branch -d client$ git branch -d server The Perils of RebasingAhh, but the bliss of rebasing isn’t without its drawbacks, which can be summed up in a single line: Do not rebase commits that exist outside your repository and people may have based work on them. If you follow that guideline, you’ll be fine. If you don’t, people will hate you, and you’ll be scorned by friends and family. When you rebase stuff, you’re abandoning existing commits and creating new ones that are similar but different. If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with git rebase and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours. For more example, please take a look in Pro Git book. SummaryWe’ve covered basic branching and merging in Git. You should feel comfortable creating and switching to new branches, switching between branches and merging local branches together. You should also be able to share your branches by pushing them to a shared server, working with others on shared branches and rebasing your branches before they are shared.","link":"/Backend/chapter-1-git-version-control/"}],"tags":[{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"tech","slug":"tech","link":"/tags/tech/"},{"name":"machine-learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"Hello World","slug":"Hello-World","link":"/categories/Hello-World/"},{"name":"Backend","slug":"Backend","link":"/categories/Backend/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"}]}