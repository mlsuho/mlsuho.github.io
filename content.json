{"pages":[],"posts":[{"title":"Become Backend Developer with Golang","text":"My objective is create this document for anyone who want to completely beginner to Backend and Golang. I hope that you guys will find useful knowledge and materials here. Thanks to Developer Roadmap, with the paths that I can take and the technologies that I want to adopt in order to become a backend developer. You can open category Backend to follow all articles and learn about it. Section I. Introduction Chapter 1: Git - Version Control Chapter 2: Basic Terminal Usage Chapter 3: Data Structures &amp; Algorithms Chapter 4: SOLID, KISS, YAGNI Chapter 5: Github Chapter 6: Licenses Chapter 7: Semantic Versioning Chapter 8: SSH Chapter 9: HTTP/HTTPS and APIs Chapter 10: Design Patterns Chapter 11: Character Encodings Section II. Backend and Go Chapter 12: Golang Chapter 13: Command Line Applications Chapter 14: Dependency Management Tool Chapter 15: Standards and Best Practices Chapter 16: Package Chapter 17: Testing Chapter 18: Relational Databases Chapter 19: Practical Chapter 20: NoSQL Database Chapter 21: Caching Chapter 22: RESTfull APIs Chapter 23: Authentication/Authorization Methodologies Chapter 24: Message Brokers Chapter 25: Search Engine Chapter 26: Docker Chapter 27: Web Servers Chapter 28: Web Socket Chapter 29: GraphQL and Graph Databases Chapter 30: Other knowledges","link":"/Backend/become-backend-developer-with-golang/"},{"title":"Introduction to Machine Learning - Part 2","text":"ChÃ o má»i ngÆ°á»i, mÃ¬nh Ä‘Ã£ quay trá»Ÿ láº¡i. Sau vÃ i tuáº§n báº­n rá»™n chuáº©n bá»‹ cho káº¿ hoáº¡ch tÆ°Æ¡ng lai cÅ©ng nhÆ° chÆ°a táº¡o Ä‘Æ°á»£c thÃ³i quen viáº¿t bÃ i, mÃ¬nh Ä‘Ã£ trá»Ÿ láº¡i vÃ  viáº¿t tiáº¿p pháº§n 2 cho chuá»—i bÃ i Introduction to Machine Learning. Introduction to Machine Learing - Part 1 History of Machine Learningá» Part 1, mÃ¬nh Ä‘Ã£ giá»›i thiá»‡u vÃ  Ä‘Æ°a má»i ngÆ°á»i tiáº¿p cáº­n khÃ¡i niá»‡m Machine Learning lÃ  gÃ¬. Tiáº¿p theo mÃ¬nh sáº½ Ä‘á» cáº­p má»™t chÃºt vá» lá»‹ch sá»­ cá»§a nÃ³. Äáº§u tiÃªn giá»›i thiá»‡u cho báº¡n má»™t bá»©c áº£nh (nguá»“n tá»« NVIDIA) Trong bá»©c áº£nh, thÃ¬ mÃ¬nh sáº½ cÃ³ 3 keyword cáº§n nÃ³i, Ä‘Ã³ lÃ  Artificial Intelligence, Machine Learning vÃ  Deep Learning. CÃ³ thá»ƒ nÃ³i thÃ¬ khi ngÃ nh khoa há»c mÃ¡y tÃ­nh xuáº¥t hiá»‡n, má»¥c tiÃªu lÃ  lÃ m ra nhá»¯ng cá»— mÃ¡y nhÆ° con ngÆ°á»i. VÃ  tá»« Ä‘Ã³, nÄƒm 1956 cÅ©ng xuáº¥t hiá»‡n khÃ¡i niá»‡m Artificial Intelligence - TrÃ­ tuá»‡ nhÃ¢n táº¡o. Sang nÄƒm 1959, má»™t lÄ©nh vá»±c con cá»§a AI lÃ  Machine Learning ra Ä‘á»i, Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a bá»Ÿi Arthur Samuel. Machine Learning lÃ  má»™t lÄ©nh vá»±c cá»§a khoa há»c mÃ¡y tÃ­nh. Machine Learning nhÆ° lÃ  má»™t phÆ°Æ¡ng phÃ¡p thÃ nh cÃ´ng Ä‘á»ƒ Ä‘áº¡t Ä‘Æ°á»£c trÃ­ thÃ´ng minh nhÃ¢n táº¡o (AI). Nhá»¯ng nÄƒm gáº§n Ä‘Ã¢y, sá»± phÃ¡t triá»ƒn cá»§a cÃ¡c há»‡ thá»‘ng cÅ©ng lÆ°á»£ng dá»¯ liá»‡u lá»›n, má»™t lÄ©nh vá»±c má»›i Ä‘Æ°á»£c ra Ä‘á»i, gá»i lÃ  Deep Learning. Deep Learning Ä‘Ã£ giÃºp mÃ¡y thá»±c thi nhá»¯ng viá»‡c tÆ°á»Ÿng chá»«ng nhÆ° khÃ´ng thá»ƒ nÃ o cÃ¡ch Ä‘Ã¢y má»™t tháº­p ká»‰, nÃ³ lÃ  táº­p con cá»§a Machine Learning. VÃ  Deep Learning chÃ­nh lÃ  má»™t trong nhá»¯ng kÄ© thuáº­t Ä‘á»ƒ triá»ƒn khai Machine Leaning. Process of Machine LearningPhÃ­a trÃªn mÃ¬nh Ä‘Ã£ chia sáº» vá» Lá»‹ch sá»­, cÅ©ng nhÆ° má»‘i liÃªn há»‡ giá»¯a Artificial Intelligence, Machine Learning vÃ  Deep Learning. Tiáº¿p theo, mÃ¬nh sáº½ chia sáº» cho má»i ngÆ°á»i vá» process cá»§a má»™t bÃ i toÃ¡n Machine Learning lÃ  nhÆ° tháº¿ nÃ o. Äáº§u tiÃªn, thá»© pháº£i nÃ³i lÃ  quan trá»ng nháº¥t trong má»™t bÃ i toÃ¡n Machine Learning Ä‘Ã³ chÃ­nh lÃ  data - dá»¯ liá»‡u. Náº¿u má»™t bÃ i toÃ¡n khÃ´ng cÃ³ dá»¯ liá»‡u thÃ¬ báº¡n khÃ´ng nÃªn Ã¡p dá»¥ng Machine Leaning vÃ o bÃ i toÃ¡n Ä‘Ã³. Sau khi cÃ³ dá»¯ liá»‡u, tuá»³ thuá»™c vÃ o bÃ i toÃ¡n cá»§a báº¡n, báº¡n sáº½ chá»n thuáº­t toÃ¡n phÃ¹ há»£p Ä‘á»ƒ phÃ¢n tÃ­ch dá»¯ liá»‡u cá»§a báº¡n. Xá»­ lÃ½ dá»¯ liá»‡u báº±ng thuáº­t toÃ¡n Machine Learning, chÃºng ta sáº½ Ä‘Æ°á»£c káº¿t quáº£ lÃ  model. Náº¿u cÃ¡c báº¡n tiáº¿p xÃºc vá»›i Machine Learning, cháº¯c cháº¯n cÃ¡c báº¡n sáº½ biáº¿t tá»›i model. Thá»±c ra cÅ©ng khÃ´ng cÃ³ gÃ¬ cao siÃªu cáº£, model nÃ³ cÅ©ng giá»‘ng nhÆ° má»™t function. Viá»‡c cá»§a chÃºng ta lÃ  Ä‘Æ°a Ä‘áº§u vÃ o vÃ o function Ä‘Ã³, nÃ³ sáº½ Ä‘Æ°a cho mÃ¬nh Ä‘áº§u ra. Cuá»‘i cÃ¹ng, mÃ¬nh tá»•ng há»£p láº¡i quÃ¡ trÃ¬nh cá»§a bÃ i toÃ¡n Machine Learning qua hÃ¬nh áº£nh nÃ y Tá»›i Ä‘Ã¢y lÃ  káº¿t thÃºc pháº§n 2 rá»“i, Pháº§n 3 tiáº¿p theo mÃ¬nh sáº½ giá»›i thiá»‡u Categories of Machine Learning - cÃ¡c loáº¡i há»c. Táº¡i sao láº¡i cÃ³ cÃ¡c loáº¡i há»c? Dá»±a vÃ o Ä‘Ã¢u Ä‘á»ƒ phÃ¢n biá»‡t? VÃ  cÃ¡c vÃ­ dá»¥. CÃ¡c báº¡n Ä‘Ã³n Ä‘á»c nhÃ© Cáº£m Æ¡n má»i ngÆ°á»i ğŸ˜˜ğŸ˜˜ğŸ˜˜","link":"/Machine-Learning/introduction-to-machine-learning-part-2/"},{"title":"Introduction to Machine Learning - Part 1","text":"ChÃ o má»i ngÆ°á»i, Ä‘Ã¢y lÃ  bÃ i blog Ä‘áº§u tiÃªn trong sá»± nghiá»‡p viáº¿t lÃ¡ch cá»§a mÃ¬nh, hy vá»ng sáº½ mang láº¡i kiáº¿n thá»©c cho má»i ngÆ°á»i. Giá»›i thiá»‡u vá» mÃ¬nh má»™t chÃºt, mÃ¬nh tÃªn lÃ  Sá»±, mÃ¬nh báº¯t Ä‘áº§u vá»›i iOS, sau nÃ y thÃ¬ cÃ³ vá»c thÃªm nhiá»u thá»©. Má»i ngÆ°á»i muá»‘n xem chi tiáº¿t vá» mÃ¬nh thÃ¬ cá»§a sang trang CV nhÃ©. Ã Ä‘á»‹nh viáº¿t blog cÅ©ng xuáº¥t hiá»‡n trong Ä‘áº§u ráº¥t lÃ  lÃ¢u rá»“i, bÃ¢y giá» má»›i ngá»“i viáº¿t má»™t cÃ¡ch nghiÃªm tÃºc. ThÃ´i trÃ¡nh lan man, mÃ¬nh Ä‘i vÃ o chá»§ Ä‘á» chÃ­nh nhÃ© ğŸ˜‰ VÃ¬ ná»™i dung mÃ¬nh muá»‘n chia sáº» hÆ¡i nhiá»u, nÃªn mÃ¬nh Ä‘Ã£ tÃ¡ch ra nhiá»u Part, cÃ¡c báº¡n nhá»› theo dÃµi nhÃ©, cáº£m Æ¡n cÃ¡c báº¡n. Why this topic?MÃ¬nh tÃ¬m hiá»ƒu Machine Learning trong vÃ²ng 5 thÃ¡ng trá»Ÿ láº¡i Ä‘Ã¢y, vÃ  Ä‘á»ƒ cÃ³ cÃ¡i gá»i lÃ  output trong 5 thÃ¡ng, thÃ¬ mÃ¬nh vÃ  má»™t anh cÃ¹ng team research Ä‘Ã£ trÃ¬nh bÃ y topic Introduction to Machine Learning trÆ°á»›c cÃ´ng ty, ngÆ°á»i tham gia buá»•i chia sáº» cá»§a tá»¥i mÃ¬nh gáº§n 80 ngÆ°á»i. Sau khi trÃ¬nh bÃ y xong, giá» mÃ¬nh chá»n nÃ³ cho bÃ i blog Ä‘áº§u tiÃªn cá»§a mÃ¬nh. VÃ  táº¥t nhiÃªn lÃ  sÆ°á»n cá»§a bÃ i blog sáº½ giá»‘ng trong slide ğŸ˜ˆğŸ˜ˆğŸ˜ˆ ÄÃ¢y lÃ  poster mÃ  phÃ­a cÃ´ng ty Ä‘Ã£ táº¡o ra cho tá»¥i mÃ¬nh, vÃ  mÃ¬nh Ä‘á»©a á»Ÿ phÃ­a trÃªn: Some interesting applicationsTrÆ°á»›c khi giá»›i thiá»‡u vá» Machine Learning, mÃ¬nh sáº½ show cho má»i ngÆ°á»i má»™t vÃ i á»©ng dá»¥ng Äáº§u tiÃªn, á»©ng dá»¥ng Face Recognition in ARKit, Ä‘Ã¢y lÃ  á»©ng dá»¥ng iOS nháº­n diá»‡n khuÃ´n máº·t má»™t ngÆ°á»i, vÃ  cho biáº¿t ngÆ°á»i Ä‘Ã³ lÃ  ai. Tiáº¿p theo, á»©ng dá»¥ng Chatbot - Speech Regnition, má»™t á»©ng dá»¥ng Web, nháº­n diá»‡n giá»ng nÃ³i sau Ä‘Ã³ xá»­ lÃ½ Ä‘á»ƒ má»™t chatbot reply. Cuá»‘i cÃ¹ng lÃ  á»©ng dá»¥ng nháº­n diá»‡n chá»¯ viáº¿t tay (cá»¥ thá»ƒ lÃ  con sá»‘), nhÆ° má»i ngÆ°á»i Ä‘Ã£ viáº¿t, má»—i ngÆ°á»i sáº½ cÃ³ cÃ¡ch viáº¿t khÃ¡c nhau, vÃ  á»©ng dá»¥ng nÃ y váº«n nháº­n diá»‡n Ä‘Æ°á»£c chá»¯ sá»‘ mÃ  mÃ¬nh viáº¿t PhÃ­a trÃªn lÃ  3 á»©ng dá»¥ng mÃ  mÃ¬nh muá»‘n chia sáº» cho má»i ngÆ°á»i tháº¥y, táº¥t nhiÃªn táº¥t cáº£ Ä‘á»u Ã¡p dá»¥ng Machine Learning. Váº­y cÃ¢u há»i Ä‘áº·t ra lÃ  táº¡i sao Machine Learning nÃ³ láº¡i Ä‘Æ°á»£c nháº¯c Ä‘áº¿n nhiá»u nhÆ° váº­y táº¡i thá»i Ä‘iá»ƒm hiá»‡n táº¡i, cÅ©ng nhÆ° viá»‡c Ã¡p dá»¥ng Machine Learning vÃ o cÃ¡c á»©ng dá»¥ng cÅ©ng khÃ´ng pháº£i lÃ  Ã­t ğŸ¤”ğŸ¤”ğŸ¤” ??!!?? Why is Machine Learning trending now?á» Ä‘Ã¢y mÃ¬nh cÃ³ 3 Ã½ muá»‘n chia sáº» tá»›i má»i ngÆ°á»i. Thá»© nháº¥t, viá»‡c pháº§n cá»©ng - hardware táº¡i thá»i Ä‘iá»ƒm hiá»‡n táº¡i Ä‘Ã£ Ä‘á»§ Ä‘Ã¡p á»©ng cho Machine Learning. Theo má»™t vÃ i thÃ´ng tin mÃ  mÃ¬nh Ä‘Ã£ Ä‘á»c, thÃ¬ pháº§n cá»©ng Ä‘Ã£ há»— trá»£ cho nhá»¯ng á»©ng dá»¥ng Machine Learning lÃ m cÃ¡c cÃ´ng viá»‡c chá»‰ tá»‘n thá»i gian 1 ~ 2 tuáº§n, trong khi náº¿u khÃ´ng cÃ³ Machine Learning thÃ¬ cÃ³ thá»ƒ máº¥t tá»›i 10 thÃ¡ng. Thá»© hai, dá»¯ liá»‡u - data ngÃ y nay cÃ³ má»™t sá»‘ lÆ°á»£ng ráº¥t lÃ  lá»›n, vÃ  táº¥t nhiÃªn nÃ³ chá»©a Ä‘á»±ng má»™t khá»‘i lÆ°á»£ng tri thá»©c cá»±c ká»³ lá»›n mÃ  con ngÆ°á»i muá»‘n khÃ¡m phÃ¡, vÃ  cÃ´ng cá»¥ Ä‘á»ƒ khÃ¡m phÃ¡ nÃ³ lÃ  gÃ¬? ChÃ­nh lÃ  Machine Learning. Cuá»‘i cÃ¹ng, Machine Learning Ä‘Ã£ mang láº¡i nhá»¯ng á»©ng dá»¥ng thá»±c táº¿ háº¿t sá»©c há»¯u Ã­ch cÅ©ng nhÆ° giáº£i quyáº¿t á»Ÿ nhiá»u lÄ©nh vá»±c nhÆ°: Sinh há»c, TÃ i chÃ­nh, Xá»­ lÃ½ ngÃ´n ngá»¯ tá»± nhiÃªn, Há»‡ thá»‘ng recommendation, Thá»‹ giÃ¡c mÃ¡y tÃ­nh, xá»§ lÃ½ hÃ¬nh áº£nh,â€¦ What is Machine Learning?NÃ£y giá» Ä‘Ã£ nÃ³i quÃ¡ nhiá»u vá» nhá»¯ng lá»£i Ã­ch mÃ  Machine Learning mang láº¡i cÅ©ng nhÆ° cÃ¡c á»©ng dá»¥ng cá»§a nÃ³, giá» mÃ¬nh báº¯t Ä‘áº§u vá»›i cÃ¢u há»i kinh Ä‘iá»ƒn Machine Learning lÃ  gÃ¬? Programming vs Machine LearningTrÆ°á»›c khi nÃ³i vá» Ä‘á»‹nh nghÄ©a cá»§a nÃ³, mÃ¬nh quay trá»Ÿ láº¡i má»™t chÃºt vá»›i Programming NhÆ° á»Ÿ hÃ¬nh trÃªn, má»i ngÆ°á»i cÃ³ thá»ƒ tháº¥y Ä‘Æ°á»£c, Ä‘á»‘i vá»›i láº­p trÃ¬nh bÃ¬nh thÆ°á»ng, khi báº¯t Ä‘áº§u Ä‘á»‹nh nghÄ©a má»™t cÃ´ng viá»‡c nÃ o Ä‘Ã³, thÃ¬ mÃ¬nh sáº½ sá»­ dá»¥ng nhá»¯ng luáº­t lá»‡ hay yÃªu cáº§u cá»¥ thá»ƒ Ä‘á»ƒ Ä‘á»‹nh nghÄ©a, rá»“i sau Ä‘Ã³, mÃ¬nh Ä‘Æ°a input (data) vÃ o, cÃ´ng viá»‡c Ä‘Ã³ sáº½ Ä‘Ã¡nh giÃ¡ input dá»±a trÃªn nhá»¯ng yÃªu cáº§u (rules) vÃ  sáº½ Ä‘Æ°a ra output (answer). NhÆ°ng khÃ¡c vá»›i Programming, Ä‘á»‘i vá»›i Machine Learning thÃ¬ sáº½ cÃ³ mÃ´ hÃ¬nh nhÆ° sau: BÃ i toÃ¡n cá»§a Machine Learning láº¡i khÃ¡c, chÃºng ta sáº½ khÃ´ng cáº§n quan tÃ¢m rules sáº½ lÃ  gÃ¬, khi báº¯t Ä‘áº§u Ä‘á»‹nh nghÄ©a má»™t cÃ´ng viá»‡c cá»§a bÃ i toÃ¡n Machine Learning thÃ¬ chÃºng ta chá»‰ cáº§n cung cáº¥p má»™t lÆ°á»£ng lá»›n cÃ¡c answers vÃ  data, Ä‘á»ƒ tá»« Ä‘Ã³, Machine Learning sáº½ há»c tá»« cÃ¡c answers Ä‘á»ƒ suy ra rules. LÃºc nÃ y mÃ¬nh Ä‘Æ°a vÃ o input vÃ  cÃ´ng viá»‡c sáº½ dá»± Ä‘oÃ¡n output. Äá»ƒ má»i ngÆ°á»i dá»… hiá»ƒu hÆ¡n vá» Programming vÃ  Machine Learning, mÃ¬nh sáº½ Ä‘Æ°a ra má»™t vÃ­ dá»¥ cá»¥ thá»ƒ, bÃ i toÃ¡n cá»§a mÃ¬nh lÃ : Äáº§u vÃ o lÃ  má»™t String, Ä‘áº§u ra lÃ  cÃ¢u tráº£ lá»i String Ä‘Ã³ cÃ³ pháº£i lÃ  email hay khÃ´ng (bÃ i toÃ¡n verify email). Äá»‘i vá»›i Programming, Ä‘á»ƒ xá»­ lÃ½ cÃ´ng viá»‡c nÃ y, mÃ¬nh sáº½ define má»™t function cÃ³ chá»©a rules lÃ : email pháº£i cÃ³ cÃ¡c kÃ­ tá»± chá»¯, sá»‘, gáº¡ch ngang, dáº¥u cháº¥mâ€¦, tiáº¿p theo lÃ  kÃ­ tá»± @, cuá»‘i cÃ¹ng lÃ  má»™t domain. LÃºc nÃ y, viá»‡c tiáº¿p theo, chá»‰ cáº§n truyá»n input lÃ  má»™t String, náº¿u Ä‘Ãºng nhÆ° rules thÃ¬ suy ra String Ä‘Ã³ lÃ  email. Äá»‘i vá»›i Machine Learning, cÃ¡i Ä‘áº§u tiÃªn mÃ¬nh cáº§n Ä‘Ã³ lÃ  answers. VÃ­ dá»¥ mÃ¬nh sáº½ cÃ³ answers: contact@mlsuho.me lÃ  email. hovansu.it@gmail.com lÃ  email. hovansu8@gmail.com lÃ  email. contact@ khÃ´ng pháº£i lÃ  email. @mlsuho.me khÃ´ng pháº£i lÃ  email.â€¦ LÃºc nÃ y mÃ¬nh sáº½ cung cáº¥p answers, viá»‡c cá»§a Machine Learning lÃ  lÃºc mÃ¬nh Ä‘Æ°a vÃ o má»™t chuá»—i String má»›i, nÃ³ pháº£i dá»± Ä‘oÃ¡n xem String Ä‘Ã³ cÃ³ pháº£i lÃ  email hay khÃ´ng. CÃ´ng viá»‡c cá»§a developer nhÆ° mÃ¬nh khÃ´ng cáº§n pháº£i Ä‘á»‹nh nghÄ©a rules ná»¯a, Ä‘Ã³ lÃ  cá»§a Machine Learning. Human vs Machine LearningMÃ¬nh Ä‘Ã£ hiá»ƒu hÆ¡n má»™t chÃºt vá» Machine Learning thÃ´ng qua Programming. Äá»ƒ má»i ngÆ°á»i náº¯m thÃªm vá» Machine Learning, mÃ¬nh xin chia sáº» thÃªm má»™t cÃ¡ch giáº£i thÃ­ch vá» nÃ³ mÃ  mÃ¬nh lÆ°á»£m láº·t Ä‘Æ°á»£c. Äáº§u tiÃªn, cÃ¡i gÃ¬ xuáº¥t hiá»‡n cÅ©ng cÃ³ má»¥c Ä‘Ã­ch cá»§a nÃ³. Machine Learning xuáº¥t hiá»‡n cho bÆ°á»›c Ä‘áº§u mong muá»‘n lÃ m ra nhá»¯ng cá»— mÃ¡y cÃ³ thá»ƒ thay tháº¿ con ngÆ°á»i. Con ngÆ°á»i chÃºng ta, khi chÃºng ta thá»±c hiá»‡n má»™t Ä‘iá»u gÃ¬ Ä‘Ã³, cÅ©ng Ä‘á»u dá»±a trÃªn kinh nghiá»‡m (experience) mÃ  ta cÃ³ Ä‘Æ°á»£c, vÃ  Ä‘á»ƒ cÃ³ kinh nghiá»‡m thÃ¬ chÃºng ta pháº£i há»c. VÃ­ dá»¥ lÃºc cÃ²n nhá», Ä‘á»ƒ há»c chá»¯ A, ta pháº£i Ä‘Æ°á»£c bá»‘ máº¹ dáº¡y, chÃºng ta sáº½ tiáº¿p xÃºc vá»›i nhiá»u chá»¯ A (há»c Ä‘Æ°á»£c nhiá»u chá»¯ A hÆ¡n), lÃºc nÃ y kinh nghiá»‡m vá» chá»¯ A cá»§a mÃ¬nh nhiá»u hÆ¡n, nÃªn bÃ¢y giá» nhÃ¬n báº¥t kÃ¬ chá»¯ A má»›i nÃ o, chÃºng ta cÅ©ng biáº¿t. CÃ²n mÃ¡y mÃ³c lÃºc nÃ y thÃ¬ sao? MÃ¡y mÃ³c thÃ¬ Ä‘Ã£ Ä‘Æ°á»£c con ngÆ°á»i láº­p trÃ¬nh, cho nÃ³ biáº¿t nÃ³ pháº£i lÃ m gÃ¬ step by step, con ngÆ°á»i Ä‘Æ°a cho mÃ¡y mÃ³c instructions. Äá»‘i vá»›i Machine Learning, lÃºc nÃ y con ngÆ°á»i Ä‘Ã£ mong muá»‘n mÃ¡y mÃ³c nhÆ° con ngÆ°á»i, khÃ´ng cÃ²n muá»‘n lÃ m theo nhá»¯ng bÆ°á»›c Ä‘Ã£ Ä‘á»‹nh nghÄ©a sáºµn. Viá»‡c há»c tá»« kinh nghiá»‡m cá»§a con ngÆ°á»i Ä‘Ã£ Ä‘Æ°á»£c Ã¡p dá»¥ng vÃ o mÃ¡y mÃ³c. NhÆ°ng khÃ´ng giá»‘ng con ngÆ°á»i lÃ  tráº£i nghiá»‡m dá»±a trÃªn kinh nghiá»‡m, mÃ¡y mÃ³c sáº½ há»c tá»« chÃ­nh data mÃ  con ngÆ°á»i cung cáº¥p, hay answer á»Ÿ phÃ­a trÃªn mÃ¬nh cÃ³ Ä‘á» cáº­p. DefinitionNÃ£y giá» mÃ¬nh Ä‘Ã£ Ä‘á» cáº­p tá»›i Programming, Human vÃ  Machine Learning báº±ng nhá»¯ng cÃ¡ch hiá»ƒu cá»§a mÃ¬nh. Giá» mÃ¬nh Ä‘Æ°a ra khÃ¡i niá»‡m cá»§a Machine Learning cá»§a Arthur Samuel - má»™t nhÃ  khoa há»c mÃ¡y tÃ­nh, ngÆ°á»i Ä‘Ã£ cho ra Ä‘á»i khÃ¡i niá»‡m Machine Learning â€œThe field of study that gives computers the ability to learn without being explicitly programmedâ€ - Arthur Samuel Táº¡m dá»‹ch lÃ : Machine Learning lÃ  má»™t lÄ©nh vá»±c trong khoa há»c mÃ¡y tÃ­nh, cÃ³ kháº£ nÄƒng tá»± há»c dá»±a trÃªn dá»¯ liá»‡u Ä‘Æ°á»£c Ä‘Æ°a vÃ o mÃ  khÃ´ng cáº§n pháº£i láº­p trÃ¬nh cá»¥ thá»ƒ. Váº­y lÃ  mÃ¬nh giá»›i thiá»‡u xong cho má»i ngÆ°á»i vá» Machine Learning lÃ  gÃ¬. Cháº¯c Part 1 sáº½ dá»«ng láº¡i á»Ÿ Ä‘Ã¢y, mÃ¬nh tháº¥y hÆ¡i dÃ i rá»“i. Háº¹n gáº·p láº¡i má»i ngÆ°á»i á»Ÿ Part 2 vá»›i nhá»¯ng ná»™i dung háº¥p dáº«n hÆ¡n ğŸ˜˜ğŸ˜˜ğŸ˜˜ Má»™t vÃ i hÃ¬nh áº£nh láº¥y tá»« cÃ¡c trang web:Face Recognition in ARKitChatbot - Speech RegnitionBuild a Handwritten","link":"/Machine-Learning/introduction-to-machine-learning-part-1/"},{"title":"Introduction to Machine Learning - Part 3","text":"Sau khoáº£ng thá»i gian Ã´n luyá»‡n tiáº¿ng anh Ä‘á»ƒ thi IELTS, giá» mÃ¬nh quay láº¡i Ä‘á»ƒ viáº¿t nhá»¯ng gÃ¬ cÃ²n dang dá»Ÿ ğŸ¤£ğŸ¤£ğŸ¤£. CÅ©ng hÆ¡n 2 thÃ¡ng má»›i viáº¿t láº¡i má»™t bÃ i, hiá»‡u suáº¥t quÃ¡ kÃ©m, mÃ¬nh sáº½ cá»‘ gáº¯ng Ä‘á»ƒ viáº¿t nhiá»u hÆ¡n vá» technical hay nhá»¯ng chia sáº» khÃ¡c. Introduction to Machine Learing - Part 1Introduction to Machine Learing - Part 2 á» pháº§n 3 nÃ y mÃ¬nh sáº½ giá»›i thiá»‡u cÃ¡c loáº¡i há»c cÃ³ trong Machine Learning. Trong Machine Learning, cÃ³ ráº¥t nhiá»u cÃ¡ch Ä‘á»ƒ giáº£i quyáº¿t má»™t bÃ i toÃ¡n, vÃ  dá»±a vÃ o nhá»¯ng dá»¯ liá»‡u Ä‘áº§u vÃ o cÅ©ng nhÆ°ng yÃªu cáº§u cá»§a bÃ i toÃ¡n, ngÆ°á»i ta Ä‘Ã£ Ä‘á»‹nh nghÄ©a ra nhá»¯ng loáº¡i há»c trong Machine Learning. HÃ´m nay mÃ¬nh sáº½ giá»›i thiá»‡u 2 loáº¡i chÃ­nh lÃ : Supervised Learning vÃ  Unsupervised Learning (ngoÃ i ra cÃ²n cÃ³ cÃ¡c loáº¡i khÃ¡c, bÃ i mÃ¬nh sáº½ khÃ´ng Ä‘á» cáº­p nhÃ©, vÃ¬ kiáº¿n thá»©c cá»§a mÃ¬nh cÅ©ng cÃ²n háº¡n cháº¿). VÃ  Ä‘á»ƒ viá»‡c chia ra cÃ¡c loáº¡i nÃ y, ngÆ°á»i ta Ä‘á»u dá»±a vÃ o data - dá»¯ liá»‡u Ä‘á»ƒ cÃ³ thá»ƒ phÃ¢n loáº¡i bÃ i toÃ¡n cáº§n thiáº¿t. MÃ¬nh sáº½ báº¯t Ä‘áº§u vá»›i Supervised Learning nhÃ©. Supervised LearningMÃ¬nh táº¡m dá»‹ch Supervised Learning(SL) sang tiáº¿ng viá»‡t lÃ  Há»c cÃ³ giÃ¡m sÃ¡t. NhÆ° mÃ¬nh Ä‘Ã£ Ä‘á» cáº­p á»Ÿ Part 2, bÃ i toÃ¡n Machine Learning lÃ  bÃ i toÃ¡n mÃ¬nh Ä‘Æ°a dá»¯ liá»‡u vÃ o rá»“i Ã¡p dá»¥ng cÃ¡c thuáº­t toÃ¡n Ä‘á»ƒ cÃ³ model. Váº­y táº¡i sao láº¡i dÃ¹ng tá»« giÃ¡m sÃ¡t, vá»›i má»™t bÃ i toÃ¡n Ã¡p dá»¥ng cÃ¡c há»c SL thÃ¬ dá»¯ liá»‡u chÃºng ta cung cáº¥p lÃ  chÃºng ta Ä‘Ã£ biáº¿t dá»¯ liá»‡u Ä‘áº§u vÃ o vÃ  Ä‘áº§u ra. Do Ä‘Ã³ chÃºng ta cÃ³ thá»ƒ â€œgiÃ¡m sÃ¡tâ€ dá»¯ liá»‡u. Äá»ƒ biáº¿t rÃµ hÆ¡n vá» Supervised Learning, vá» dá»¯ liá»‡u biáº¿t Ä‘áº§u vÃ o vÃ  Ä‘áº§u ra, mÃ¬nh sáº½ Ä‘á» cáº­p vá» 2 kÄ© thuáº­t chÃ­nh cá»§a cÃ¡ch há»c nÃ y Ä‘Ã³ lÃ : Classification vÃ  Regression. ClassificationÄáº§u tiÃªn mÃ¬nh sáº½ nÃ³i tá»›i Classification (phÃ¢n loáº¡i) trong Supervised Learning. ÄÃ¢y lÃ  má»™t trong nhá»¯ng kÄ© thuáº­t tÃ¬m hiá»ƒu vÃ  nghiÃªn cá»©u nhiá»u nháº¥t trong Machine Learning. Sau khi Ã¡p dá»¥ng kÄ© thuáº­t nÃ y, model sáº½ cÃ³ kháº£ nÄƒng dá»± Ä‘oÃ¡n cÃ¡c giÃ¡ trá»‹ theo kiá»ƒu phÃ¢n loáº¡i. MÃ¬nh sáº½ cÃ³ nhá»¯ng vÃ­ dá»¥ Ä‘á»ƒ má»i ngÆ°á»i dá»… hiá»ƒu, nhá»¯ng á»©ng dá»¥ng nhÆ° phÃ¢n loáº¡i chÃ³ mÃ¨o khi mÃ¬nh cung cáº¥p má»™t hÃ¬nh áº£nh vá» chÃ³ hoáº·c mÃ¨o, hay á»©ng dá»¥ng phÃ¢n biá»‡t loÃ i hoa há»“ng hay hoa lan, ngoÃ i ra cÃ¡c á»©ng dá»¥ng nháº­n diá»‡n máº·t hay Ä‘á»‘i tÆ°á»£ngâ€¦ cÃ¡c á»©ng dá»¥ng Ä‘Ã³ Ä‘á»u lÃ  cÃ¡c vÃ­ dá»¥ sá»­ dá»¥ng Classification. Äá»ƒ rÃµ hÆ¡n, mÃ¬nh sáº½ phÃ¢n tÃ­ch má»™t bÃ i toÃ¡n cá»¥ thá»ƒ nhÃ© Dá»± Ä‘oÃ¡n giá»›i tÃ­nh dá»±a trÃªn chiá»u cao vÃ  cÃ¢n náº·ng VÃ  dá»¯ liá»‡u cá»§a bÃ i toÃ¡n Giá» báº¯t Ä‘áº§u phÃ¢n tÃ­ch má»™t chÃºt nhÃ©, vá»›i bÃ i toÃ¡n nÃ y, theo yÃªu cáº§u, thÃ¬ Ä‘áº§u vÃ o cá»§a chÃºng ta sáº½ lÃ  chiá»u cao vÃ  cÃ¢n náº·ng cÃ²n Ä‘áº§u ra sáº½ lÃ  giá»›i tÃ­nh. Tiáº¿p theo khi nhÃ¬n vÃ o táº­p dá»¯ liá»‡u Ä‘á»ƒ train, thÃ¬ chÃºng ta Ä‘Ã£ cÃ³ Ä‘áº§y Ä‘á»§ input vÃ  output. Váº­y á»Ÿ Ä‘Ã¢y loáº¡i há»c mÃ¬nh sáº½ Ã¡p dá»¥ng lÃ  Supervised Learning. Sau Ä‘Ã³ nhÃ¬n vÃ o output mÃ¬nh sáº½ tháº¥y giá»›i tÃ­nh á»Ÿ Ä‘Ã¢y chá»‰ cÃ³ Nam hoáº·c Ná»¯, Ä‘Ã¢y lÃ  phÃ¢n loáº¡i giá»›i tÃ­nh, nÃªn kÄ© thuáº­t mÃ¬nh dÃ¹ng sáº½ lÃ  Classification. Sau khi cÃ³ bÃ i toÃ¡n vÃ  dá»¯ liá»‡u thÃ¬ chÃºng ta cÃ³ thá»ƒ phÃ¢n tÃ­ch Ä‘Æ°á»£c kÄ© thuáº­t mÃ  mÃ¬nh sá»­ dá»¥ng sáº½ lÃ  gÃ¬. Khi nháº¯c tá»›i Machine Learning thÃ¬ mÃ¬nh khÃ´ng thá»ƒ nháº¯c tá»›i thuáº­t toÃ¡n cá»§a má»—i kÄ© thuáº­t. Vá»›i Classification, mÃ¬nh xin giá»›i thiá»‡u tá»›i má»i ngÆ°á»i má»™t vÃ i thuáº­t toÃ¡n, náº¿u má»i ngÆ°á»i thÃ­ch thÃ¬ cÃ³ thá»ƒ tÃ¬m hiá»ƒu Ä‘á»ƒ Ã¡p dá»¥ng vÃ o bÃ i toÃ¡n cá»§a mÃ¬nh CÃ¡c thuáº­t toÃ¡n: Support vector machine (SVM) Decision tree K-nearest neighbor NaÃ¯ve Bayes Neural networks RegressionMá»™t kÄ© thuáº­t thá»© hai trong Supervised Learning lÃ  Regression (Há»“i Quy). KhÃ¡c vá»›i Classification kÄ© thuáº­t nÃ y Ã¡p dá»¥ng cho nhá»¯ng bÃ i toÃ¡n cÃ³ model dá»± Ä‘oÃ¡n nhá»¯ng giÃ¡ trá»‹ thá»±c (nhá»¯ng con sá»‘). MÃ¬nh sáº½ Ä‘á» cáº­p chi tiáº¿t á»Ÿ vÃ­ dá»¥ Ä‘á»ƒ má»i ngÆ°á»i hiá»ƒu rÃµ hÆ¡n. Nhá»¯ng á»©ng dá»¥ng cÃ³ sá»­ dá»¥ng kÄ© thuáº­t nÃ y: Dá»± Ä‘oÃ¡n tuá»•i dá»±a trÃªn hÃ¬nh áº£nh, hay á»©ng dá»¥ng dá»± Ä‘oÃ¡n nhiá»‡t Ä‘á»™ cá»§a ngÃ y mai. Äá»ƒ má»i ngÆ°á»i hiá»ƒu rÃµ hÆ¡n thÃ¬ mÃ¬nh sáº½ cÃ³ vÃ­ dá»¥ nhÆ° tháº¿ nÃ y Dá»± Ä‘oÃ¡n cÃ¢n náº·ng dá»±a trÃªn chiá»u cao Ta sáº½ phÃ¢n tÃ­ch bÃ i toÃ¡n vÃ  dá»¯ liá»‡u train Ä‘á»ƒ chá»n kÄ© thuáº­t nhÃ©. Äáº§u tiÃªn, bÃ i toÃ¡n nÃ y vá»›i input lÃ  chiá»u cao vÃ  output lÃ  cÃ¢n náº·ng. Dá»±a vÃ o dá»¯ liá»‡u train, ta Ä‘á»u tháº¥y input vÃ  output cá»§a dá»¯ liá»‡u, nÃªn chÃºng ta sáº½ Ã¡p dá»¥ng cÃ¡ch há»c Supervised Learning. Tiáº¿p theo Ä‘á»ƒ Ã½ output cá»§a dá»¯ liá»‡u, khÃ´ng giá»‘ng á»Ÿ vÃ­ dá»¥ cá»§a pháº§n Classifiation, output lÃ  giá»›i tÃ­nh Nam hoáº·c Ná»¯, á»Ÿ vÃ­ dá»¥ nÃ y, output lÃ  má»™t con sá»‘, vÃ  mÃ¬nh khÃ´ng biáº¿t trÆ°á»›c cá»¥ thá»ƒ vá» output. Khi gáº·p bÃ i toÃ¡n vÃ  dá»¯ liá»‡u nÃ y, mÃ¬nh sáº½ Ã¡p dá»¥ng kÄ© thuáº­t Regression VÃ  cÃ¡c thuáº­t toÃ¡n trong Regression lÃ : Linear / Nonlinear model Regularization Stepwise regression Bagged decision trees Neural networks Unsupervised LearningTiáº¿p theo chÃºng ta sáº½ qua loáº¡i há»c thá»© hai lÃ  Há»c khÃ´ng giÃ¡m sÃ¡t - Unsupervised Learning. Vá» pháº§n nÃ y thÃ¬ mÃ¬nh chÆ°a lÃ m + chÆ°a cÃ³ kinh nghiá»‡m nÃªn chá»‰ cÃ³ thá»ƒ chia sáº» kiáº¿n thá»©c lÃ½ thuyáº¿t mÃ  mÃ¬nh hiá»ƒu Ä‘Æ°á»£c vá» nÃ³, rá»“i chia sáº» cho má»i ngÆ°á»i cÃ¹ng biáº¿t. Äáº§u tiÃªn, Unsupervised Learning ngÆ°á»£c láº¡i vá»›i Supervised Learning, nÃ³ khÃ´ng hÆ°á»›ng tá»›i viá»‡c tÃ¬m má»™t correct output. Váº­y model khi sá»­ dá»¥ng Unsupervised Learning thÃ¬ Ä‘Æ°a ra output gÃ¬? Model nÃ y hÆ°á»›ng tá»›i viá»‡c tÃ¬m ra cÃ¡c structure, relationshiprelationship áº©n sÃ¢u trong dá»¯ liá»‡u mÃ  ta khÃ´ng tháº¥y Ä‘Æ°á»£c. VÃ  má»™t Ä‘iá»u Ä‘áº·t biáº¿t cá»§a táº­p dá»¯ liá»‡u train sáº½ khÃ´ng cÃ³ Ä‘áº§u ra, mÃ¬nh chá»‰ cung cáº¥p dá»¯ liá»‡u cÃ³ Ä‘áº§u vÃ o. VÃ  kÄ© thuáº­t thÆ°á»ng Ä‘Æ°á»£c sá»­ dá»¥ng trong Unsupervised Learning lÃ  Clustering (PhÃ¢n cá»¥m). VÃ­ dá»¥ má»™t chÃºt nhÃ©, mÃ¬nh Ä‘ang bÃ¡n má»™t máº·t hÃ ng, nhÆ° cÃ¢y bÃºt vÃ  khÃ¡ch hÃ ng cá»§a mÃ¬nh lÃ  khÃ¡c nhau, tá»« há»c sinh, sinh viÃªn hay doanh nhÃ¢n. Sau khi mua hÃ ng cá»§a mÃ¬nh, mÃ¬nh sáº½ cÃ³ dá»¯ liá»‡u cá»§a khÃ¡ch hÃ ng. Sau Ä‘Ã³ mÃ¬nh Ã¡p dá»¥ng Unsupervised Learning vÃ o dá»¯ liá»‡u cá»§a mÃ¬nh, cÃ³ thá»ƒ mÃ¬nh sáº½ tÃ¬m ra Ä‘iá»ƒm chung cá»§a khÃ¡ch hÃ ng cá»§a mÃ¬nh, rá»“i tá»« Ä‘iá»ƒm chung Ä‘Ã³, mÃ¬nh sáº½ quáº£ng cÃ¡o tá»›i nhá»¯ng ngÆ°á»i khÃ¡c dá»±a vÃ o Ä‘iá»ƒm chung Ä‘Ã³, vá»«a nÃ¢ng cao lá»£i nhuáº­n vá»«a tiáº¿t kiáº¿m chi phÃ­ quáº£ng cÃ¡o. ClusteringTiáº¿p theo mÃ¬nh sáº½ nÃ³i vá» kÄ© thuáº­t Clustering (PhÃ¢n cá»¥m) trong Unsupervised Learning. KÄ© thuáº­t nÃ y dÃ¹ng Ä‘á»ƒ phÃ¢n nhÃ³m toÃ n bá»™ dá»¯ liá»‡u thÃ nh cÃ¡c nhÃ³m nhá» khÃ¡c nhau dá»±a vÃ o sá»± liÃªn quan vá» tÃ­nh cháº¥t cÃ¡c dá»¯ liá»‡u vá» cÃ¡c nhÃ³m MÃ¬nh sáº½ cÃ³ hÃ¬nh áº£nh vÃ­ dá»¥ vá» á»©ng dá»¥ng nháº­n dáº¡ng sá»‘ Nguá»“n datascienceplus á» Ä‘Ã¢y, Ä‘áº§u vÃ o dá»¯ liá»‡u lÃ  mÃ¬nh cung cáº¥p cÃ¡c sá»‘ mÃ  mÃ¬nh khÃ´ng cho biáº¿t Ä‘Ã³ lÃ  sá»‘ nÃ o, thÃ´ng qua kÄ© thuáº­t Cluster, nÃ³ sáº½ tá»± phÃ¢n loáº¡i gáº§n nhÆ° chÃ­nh xÃ¡c cÃ¡c sá»‘ Ä‘Ã³ dá»±a trÃªn cÃ¡c nÃ©t váº½ cá»§a cÃ¡c chá»¯ sá»‘ Ä‘Ã³. (cÃ³ thá»ƒ sáº½ cÃ³ má»™t sai sá»‘ nhÆ° hÃ¬nh phÃ­a trÃªn) MÃ¬nh sáº½ chia sáº» thÃªm má»™t vÃ i thuáº­t toÃ¡n cá»§a kÄ© thuáº­t Clustering: K-means and k-medoids Hierarchical clustering Gaussian mixture models Hidden Markov models Fuzzy c-means clustering Tá»›i Ä‘Ã¢y lÃ  mÃ¬nh Ä‘Ã£ káº¿t thÃºc pháº§n 3 cÅ©ng nhÆ° chuá»—i bÃ i vá» Introduction to Machine Learning. Cáº£m Æ¡n má»i ngÆ°á»i Ä‘Ã£ theo dÃµi. CÃ³ gÃ¬ tháº¯c máº¯c hoáº·c bÃ i viáº¿t mÃ¬nh sai xÃ³t, má»i ngÆ°á»i cá»© bÃ¬nh luáº­n.","link":"/Machine-Learning/introduction-to-machine-learning-part-3/"},{"title":"Chapter 1 - Git - Version Control","text":"Everything you need to know about git. Thanks to Scott Chacon and Ben Straub, authors of the book Pro Git In this chapter, I will show basic knowledges from Pro Git book, if you want more detail, you should download the book and read it. Getting StartedThis section will be about getting started with Git, then move on how to get Git running on system and set up to start working with. Version ControlVersion control is a system that records changes to a file or set of files over time so that you can recall specific versions later. If you are a developer and you want to keep every version of your code, a Version Control System (VCS) is a very wise thing to use. It allows you to revert selected files back to a previous state, revert the entire project back to a previouse state, compare changes over time, see who last modified something that might be causing a problem (then you can burn them ğŸ¤£ğŸ¤£ğŸ¤£), and more. Git is a Distributed Version Control System (DVCS), in a DVCS, clients donâ€™t just check out the latest snapshot of the files; rather, the fully mirror the repository, including its full history. Thus, if any server dies, and these systems were collaborating via the server, any of the client repositories can be copied back up to the server to restore it. What is Git?So, what is Git in a nutshell? Snapshots, Not DifferencesWith Git, every time you commit, or save the state of your project, Git basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot. To be efficient, if files have not changed, Git doesnâ€™t store the file again, just a link to the previous identical file it has already stored. Nearly Every Operation Is LocalMost operations in Git need only local fils and resources to operate - generally no information is needed from another computer on your network. You have the entire history of the project right there on your local disk, most operations seem almost instantaneous. For example, to browse the history of the proejct, Git doesnâ€™t need to go out to the sever to get the history and display it for you - it simply reads it directly from your local database. Git Has IntegrityEverything in Git is checksummed before it is stored and is then referred to by that checksums. This means itâ€™s impossible to change to contents of any file or directory without Git knowing about it. Git Generally Only Adds DataWhen you do actions in Git, nearly all of them only add data to the Git database. It is hard to get the system to do anything that is not undoable or to make it erase data in any way. After you commit a a snapshot into Git, it is very difficult to lose, especially if you regularly push your database to another repository. This makes using Git a joy because we know we can experiment without the danger of severely screwing things up. The Three StatesPay attention now - here is the main thing to remember about Git if you want the rest of your learning process to go smoothly. Git has three main states that your files can reside in: committed, modified, and staged: Committed means that the data is safely stored in your local database Modifed means that you have changed the file but have not committed it to your database yet. Staged means that you have marked a modified file in its current version to go into your next commit snapshot The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer The working tree (working directory) is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify. The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit. The basic Git workflow goes something like this: You modify files in your working tree You selectively stage just those changes you want to be part of your next commit, which adds only those changes to the staging area. You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory. The Command LineThere are a lot of different ways to use Git. There are the original command-line tools, and there are many graphical user interfaces of varying capabilities. For backend developer, I suggest using Git on the command line. For one, the command line is the only place you can run all Git commands. Installing GitYou need to go to the website git-scm.com for download and install Git. After download and install, run git from terminal the very first time 1git --version First-Time Git SetupNow that you have Git on your system, you will want to do a few things to customize your Git environment. First, you can view all of your settings and where they are coming from using: 1git config --list --show-origin Your IdentityThe first thing you should do when you install Git is set your username and email address. This is important because every Git commit uses this information, and itâ€™s immutably baked into the commits you start creating 12$ git config --global user.name suho$ git config --global user.email suho@example.com Because Git will always use that information for anything you do on that system so you need to to do this only once if you pass the --global option. Without --global, you will use different name or email for specific projects. Checking Your SettingsIf you want to check your configuration, run: 1git config --list Git BasicsIn this section, we will learn how to use Git in the 80% of cases youâ€™ll encounter most often. After this section, you will be able to clone a repository, see what has happened in the history of the project, modify files, and contribute changes. Getting a Git RepositoryYou typically obtain a Git repository in one of two ways: You can take a local directory that is currently not under version control, and turn it into a Git repository, or You can clone an existing Git repository from elsewhere. Initializing a Repository in an Existing DirectoryYou first need to go to that projectâ€™s directory. 1$ cd ~/your-project and type: 1$ git init This creates a new subdirectory named .git that contains all of your necessary repository files â€” a Git repository skeleton Cloning an Existing RepositoryIf you want to get a copy of an existing Git repository â€” for example, a project youâ€™d like to contribute to â€” the command you need is git clone. Every version of every file for the history of the project is pulled down by default when you run git clone. Recording Changes to the RepositoryEach file in your working directory can be in one of two states: tracked or untracked. Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged. In short, tracked files are files that Git knows about. Untracked files are everything else â€” any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you havenâ€™t edited anything. Checking the Status of Your FilesThe main tool you use to determine which files are in which state is the git status command. 1$ git status Tracking New FilesIn order to begin tracking a new file, you use the command git add. To begin tracking the README file, you can run this: 1$ git add [fileName] Staging Modified Filesgit add is a multipurpose command â€” you use it to begin tracking new files, to stage files, and to do other things like marking merge-conflicted files as resolved. Short StatusWhile the git status output is pretty comprehensive, itâ€™s also quite wordy. Git also has a short status flag so you can see your changes in a more compact way 1$ git status -s Ignoring FilesOften, youâ€™ll have a class of files that you donâ€™t want Git to automatically add or even show you as being untracked. These are generally automatically generated files such as log files or files produced by your build system. In such cases, you can create a file listing patterns to match them named .gitignore. Here is an example .gitignore file: 123456789101112# ignore all .a files*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in any directory named buildbuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directory and any of its subdirectoriesdoc/**/*.pdf The rules for the patterns you can put in the .gitignore file are as follows: Blank lines or lines starting with # are ignored. Standard glob patterns work, and will be applied recursively throughout the entire working tree. You can start patterns with a forward slash (/) to avoid recursivity. You can end patterns with a forward slash (/) to specify a directory. You can negate a pattern by starting it with an exclamation point (!). Viewing Your Staged and Unstaged ChangesIf you want to know exactly what you changed, not just which files were changed â€” you can use the git diff command 1$ git diff Committing Your ChangesNow that your staging area is set up the way you want it, you can commit your changes. Remember that anything that is still unstaged â€” any files you have created or modified that you havenâ€™t run git add on since you edited them â€” wonâ€™t go into this commit. They will stay as modified files on your disk. In this case, letâ€™s say that the last time you ran git status, you saw that everything was staged, so youâ€™re ready to commit your changes. The simplest way to commit is to type git commit: 1$ git commit Alternatively, you can type your commit message inline with the commit command by specifying itafter a -m flag, like this: 1$ git commit -m \"Story 01: Fix Login UI` Viewing the Commit HistoryAfter you have created several commits, or if you have cloned a repository with an existing commit history, youâ€™ll probably want to look back to see what has happened. The most basic and powerful tool to do this is the git log command. 1$ git log Common Options to git log Option Description -p Show the patch introduced with each commit. â€“stat Show statistics for files modified in each commit. â€“shortstat Display only the changed/insertions/deletions line from the â€“stat command. â€“name-only Show the list of files modified after the commit information. â€“name-status Show the list of files affected with added/modified/deleted information as well. â€“abbrev-commit Show only the first few characters of the SHA-1 checksum instead of all 40. â€“relative-date Display the date in a relative format (for example, â€œ2 weeks agoâ€) instead of using the full date format. â€“graph Display an ASCII graph of the branch and merge history beside the log output. â€“pretty Show commits in an alternate format. Options include oneline, short, full, fuller, and format (where you specify your own format). â€“oneline Shorthand for â€“pretty=oneline â€“abbrev-commit used together Undoing ThingsOne of the common undos takes place when you commit too early and possibly forget to add some files, or you mess up your commit message. If you want to redo that commit, make the additional changes you forgot, stage them, and commit again using the â€“amend option: 1$ git commit --amend Unstaging a Staged FileUse git reset HEAD &lt;file&gt;... to unstage. Itâ€™s true that git reset can be a dangerous command, especially if you provide the --hard flag. However, in the scenario described above, the file in your working directory is not touched, so itâ€™s relatively safe. Unmodifying a Modified FileWhat if you realize that you donâ€™t want to keep your changes to the CONTRIBUTING.md file? How can you easily unmodify it â€” revert it back to what it looked like when you last committed. Use git checkout -- &lt;file&gt;... to discard changes in working directory. Working with RemotesTo be able to collaborate on any Git project, you need to know how to manage your remote repositories. Remote repositories are versions of your project that are hosted on the Internet or network somewhere. Remote repositories can be on your local machine. Showing your remotesTo see which remote servers you have configured, you can run the git remote command. 1$ git remote You can also specify -v, which shows you the URLs that Git has stored for the shortname to be used when reading and writing to that remote. 1$ git remote -v Adding Remote RepositoriesHereâ€™s how to add a new remote explicitly. To add a new remote Git repository as a shortname you can reference easily, run git remote add &lt;shortname&gt; &lt;url&gt;: 1$ git remote add suho https://github.com/suho/backend-and-go Now you can fetch all the information 1$ git fetch suho Fetching and Pulling from Your RemotesAs you just saw, to get data from your remote projects, you can run: 1$ git fetch &lt;remote&gt; If your current branch is set up to track a remote branch, you can use the git pull command to automatically fetch and then merge that remote branch into your current branch. Pushing to Your RemotesWhen you have your project at a point that you want to share, you have to push it upstream. The command for this is simple: git push &lt;remote&gt; &lt;branch&gt;. If you want to push your master branch to your origin server (again, cloning generally sets up both of those names for you automatically), then you can run this to push any commits youâ€™ve done back up to the server: 1$ git push origin master Inspecting a RemoteIf you want to see more information about a particular remote, you can use the git remote show &lt;remote&gt; command. 1$ git remote show origin Renaming and Removing RemotesYou can run git remote rename to change a remoteâ€™s shortname. For instance, if you want to renamesuho to sh, you can do so with git remote rename: 1$ git remove remove suho sh TaggingGit has the ability to tag specific points in a repositoryâ€™s history as being important. Typically, people use this functionality to mark release points (v1.0, v2.0 and so on). In this section, youâ€™ll learn how to list existing tags, how to create and delete tags, and what the different types of tags are. Listing Your TagsListing the existing tags in Git is straightforward. Just type git tag (with optional -l or â€“list): 1$ git tag Creating TagsGit supports two types of tags: lightweight and annotated. A lightweight tag is very much like a branch that doesnâ€™t change â€” itâ€™s just a pointer to a specific commit. Annotated tags, however, are stored as full objects in the Git database. Theyâ€™re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). Itâ€™s generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason donâ€™t want to keep the other information, lightweight tags are available too. Annotated Tags Creating an annotated tag in Git is simple. The easiest way is to specify -a when you run the tag command: 1$ git tag -a v0.0.1 -m \"Version 0.0.1\" You can see the tag data with git show command 1$ git show v0.0.1 Lightweight Tags Another way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file â€” no other information is kept. To create a lightweight tag, donâ€™t supply any of the -a, -s, or -m options, just provide a tag name: 1$ git tag v0.0.2-lw If you run git show on the tag (v0.0.2-lw), you donâ€™t see the extra tag information. Sharing TagsBy default, the git push command doesnâ€™t transfer tags to remote servers. You will have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches â€” you can run git push origin &lt;tagname&gt; 1234$ git push origin v0.0.1# Push all tagsgit push origin --tags Deleting TagsTo delete a tag on your local repository, you can use git tag -d &lt;tagname&gt;. For example, we could remove our lightweight tag above as follows: 1$ git tag -d v0.0.2-lw Note that this does not remove the tag from any remote servers. The way to delete a remote tag is with: 1$ git push origin --delete &lt;tagname&gt; Checking out TagsIf you want to view the versions of files a tag is pointing to, you can do a git checkout of that tag 1$ git checkout v0.0.1 Git BranchingBranching means you diverge from the main line of development and continue to do work without messing with that main line. Gitâ€™s branching model as its killer feature. The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast. Branches in a NutshellThe default branch name in Git is master. As you start making commits, youâ€™re given a master branch that points to the last commit you made. Every time you commit, the master branch pointer moves forward automatically. The â€œmasterâ€ branch in Git is not a special branch. It is exactly like any other branch. The only reason nearly every repository has one is that the git init command creates it by default and most people donâ€™t bother to change it. Creating a New BranchWhat happens when you create a new branch? Well, doing so creates a new pointer for you to move around. Letâ€™s say you want to create a new branch called testing. You do this with the git branch command: 1$ git branch testing This creates a new pointer to the same commit youâ€™re currently on. The git branch command only created a new branch â€” it didnâ€™t switch to that branch. Switching BranchesTo switch to an existing branch, you run the git checkout command. Letâ€™s switch to the new testing branch: 1$ git checkout testing This moves HEAD to point to the testing branch. The HEAD branch moves forward when a commit is made This is interesting, because now your testing branch has moved forward, but your master branch still points to the commit you were on when you ran git checkout to switch branches. Letâ€™s switch back to the master branch: 1$ git checkout master Now, letâ€™s make a few changes and commit again. Basic Branching and MergingLetâ€™s go through a simple example of branching and merging with a workflow that you might use inthe real world. Youâ€™ll follow these steps: Do some work on a website. Create a branch for a new user story youâ€™re working on. Do some work in that branch. At this stage, youâ€™ll receive a call that another issue is critical and you need a hotfix. Youâ€™ll do thefollowing: Switch to your production branch. Create a branch to add the hotfix. After itâ€™s tested, merge the hotfix branch, and push to production. Switch back to your original user story and continue working. Basic BranchingFirst, letâ€™s say youâ€™re working on your project and have a couple of commits already on the master branch. Youâ€™ve decided that youâ€™re going to work on issue #53 in whatever issue-tracking system your company uses. To create a new branch and switch to it at the same time, you can run the git checkout command with the -b switch: 1$ git checkout -b iss53 This is shorthand for: 12$ git branch iss53git checkout iss53 You work on your website and do some commits. Doing so moves the iss53 branch forward, because you have it checked out (that is, your HEAD is pointing to it). Now you get the call that there is an issue with the website, and you need to fix it immediately. With Git, you donâ€™t have to deploy your fix along with the iss53 changes youâ€™ve made, and you donâ€™t have to put a lot of effort into reverting those changes before you can work on applying your fix to what is in production. All you have to do is switch back to your master branch. 1$ git checkout master Next, you have a hotfix to make. Letâ€™s create a hotfix branch on which to work until itâ€™s completed 1$ git checkout -b hotfix You can run your tests, make sure the hotfix is what you want, and finally merge the hotfix branch back into your master branch to deploy to production. You do this with the git merge command 12$ git checkout mastergit merge hotfix After your super-important fix is deployed, youâ€™re ready to switch back to the work you were doing before you were interrupted. However, first youâ€™ll delete the hotfix branch, because you no longer need it â€” the master branch points at the same place. You can delete it with the -d option to git branch: 1$ git branch -d hotfix Now you can switch back to your work-in-progress branch on issue #53 and continue working on it. 1$ git checkout iss53 Itâ€™s worth noting here that the work you did in your hotfix branch is not contained in the files in your iss53 branch. If you need to pull it in, you can merge your master branch into your iss53 branch by running git merge master, or you can wait to integrate those changes until you decide to pull the iss53 branch back into master later. Basic MergingSuppose youâ€™ve decided that your issue #53 work is complete and ready to be merged into your master branch. In order to do that, youâ€™ll merge your iss53 branch into master, much like you merged your hotfix branch earlier. All you have to do is check out the branch you wish to merge into and then run the git merge command: 12$ git checkout mastergit merge iss53 Now that your work is merged in, you have no further need for the iss53 branch. You can close the ticket in your ticket-tracking system, and delete the branch: 1$ git branch -d iss53 Basic Merge ConflictsOccasionally, this process doesnâ€™t go smoothly. If you changed the same part of the same file differently in the two branches youâ€™re merging, Git wonâ€™t be able to merge them cleanly. If your fix for issue #53 modified the same part of a file as the hotfix branch, youâ€™ll get a merge conflict that looks something like this 1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. Anything that has merge conflicts and hasnâ€™t been resolved is listed as unmerged. Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts. Your file contains a section that looks something like this: 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=\"footer\"&gt;Contact : e.support@example.com&lt;/div&gt;=======&lt;div id=\"footer\"&gt;Please contact us at support@example.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html This means the version in HEAD (your master branch, because that was what you had checked out when you ran your merge command) is the top part of that block (everything above the =======), while the version in your iss53 branch looks like everything in the bottom part. In order to resolve the conflict, you have to either choose one side or the other or merge the contents yourself. For instance, you might resolve this conflict by replacing the entire block with this: 123&lt;div id=\"footer\"&gt;please contact us at email.support@github.com&lt;/div&gt; Branch ManagementNow that youâ€™ve created, merged, and deleted some branches, letâ€™s look at some branchmanagement tools that will come in handy when you begin using branches all the time. The git branch command does more than just create and delete branches. If you run it with no arguments, you get a simple listing of your current branches: 1234$ git branch iss53* master testing Notice the * character that prefixes the master branch: it indicates the branch that you currentlyhave checked out (i.e., the branch that HEAD points to) To see the last commit on each branch, you can run git branch -v: 1$ git branch -v The useful --merged and --no-merged options can filter this list to branches that you have or have not yet merged into the branch youâ€™re currently on 12$ git branch --merged$ git branch --no-merged RebasingIn Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase. In this section youâ€™ll learn what rebasing is, how to do it, why itâ€™s a pretty amazing tool, and in what cases you wonâ€™t want to use it. The Basic RebaseIf you go back to an earlier example from Basic Merging, you can see that you diverged your workand made commits on two different branches. The easiest way to integrate the branches, as weâ€™ve already covered, is the merge command. However, there is another way: you can take the patch of the change that was introduced in C4 and reapply it on top of C3. In Git, this is called rebasing. With the rebase command, you can take all the changes that were committed on one branch and replay them on a different branch. For this example, you would check out the experiment branch, and then rebase it onto the master branch as follows 12$ git checkout experiment$ git rebase master At this point, you can go back to the master branch and do a fast-forward merge. 12$ git checkout master$ git merge experiment More Interesting RebasesYou can also have your rebase replay on something other than the rebase target branch. For example, you branched a topic branch (server) to add some server-side functionality to your project, and made a commit. Then, you branched off that to make the client-side changes (client) and committed a few times. Finally, you went back to your server branch and did a few more commits. Suppose you decide that you want to merge your client-side changes into your mainline for a release, but you want to hold off on the server-side changes until itâ€™s tested further. You can take the changes on client that arenâ€™t on server (C8 and C9) and replay them on your master branch by using the --onto option of git rebase: 1$ git rebase --onto master server client This basically says, â€œTake the client branch, figure out the patches since it diverged from the server branch, and replay these patches in the client branch as if it was based directly off the master branch instead.â€ Itâ€™s a bit complex, but the result is pretty cool. Now you can fast-forward your master branch 12$ git checkout master$ git merge client Letâ€™s say you decide to pull in your server branch as well. You can rebase the server branch onto the master branch without having to check it out first by running git rebase &lt;basebranch&gt; &lt;topicbranch&gt; â€” which checks out the topic branch (in this case, server) for you and replays it onto the base branch (master): 1$ git rebase master server Then, you can fast-forward the base branch (master): 12$ git checkout master$ git merge server You can remove the client and server branches because all the work is integrated and you donâ€™t need them anymore 12$ git branch -d client$ git branch -d server The Perils of RebasingAhh, but the bliss of rebasing isnâ€™t without its drawbacks, which can be summed up in a single line: Do not rebase commits that exist outside your repository and people may have based work on them. If you follow that guideline, youâ€™ll be fine. If you donâ€™t, people will hate you, and youâ€™ll be scorned by friends and family. When you rebase stuff, youâ€™re abandoning existing commits and creating new ones that are similar but different. If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with git rebase and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours. For more example, please take a look in Pro Git book. SummaryWeâ€™ve covered basic branching and merging in Git. You should feel comfortable creating and switching to new branches, switching between branches and merging local branches together. You should also be able to share your branches by pushing them to a shared server, working with others on shared branches and rebasing your branches before they are shared.","link":"/Backend/chapter-1-git-version-control/"}],"tags":[{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"tech","slug":"tech","link":"/tags/tech/"},{"name":"machine-learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"Hello World","slug":"Hello-World","link":"/categories/Hello-World/"},{"name":"Backend","slug":"Backend","link":"/categories/Backend/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"}]}